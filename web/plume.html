<head>
    <style>
        /* Positionning% */
* {
  box-sizing: border-box;
}
body {
    display: flex;
}

body div {
  width:45vw;
  height: 70vh;
  margin: 5vw;
}

#input, #output {
  width: 100%;
  height: 60vh;
  margin: 0;
}

/* General styles for the page body */
body {
  font-family: 'Roboto', sans-serif;
  background-color: #f4f7f9;
  color: #333;
  padding: 20px;
  line-height: 1.6;
}

#input {
  background-color: #ffffff;
  border: 2px solid #e0e6ed;
  border-radius: 8px;
  padding: 15px;
  font-size: 16px;
  color: #444;
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.05);
  transition: border-color 0.3s ease, box-shadow 0.3s ease;
  resize: none;
  overflow-y: auto;
}

#input:focus {
  border-color: #007bff;
  box-shadow: 0 3px 6px rgba(0, 123, 255, 0.1);
  outline: none;
}

#output {
  background-color: #ffffff;
  border: 2px solid #e0e6ed;
  border-radius: 8px;
  padding: 15px;
  font-size: 16px;
  color: #444;
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.05);
  overflow-y: auto;
}

::-webkit-scrollbar {
  width: 8px;
  height: 8px;
}

::-webkit-scrollbar-track {
  background: #f1f1f1;
  border-radius: 8px;
}

::-webkit-scrollbar-thumb {
  background: #c1c1c1;
  border-radius: 8px;
}

::-webkit-scrollbar-thumb:hover {
  background: #a8a8a8;
}


h1 {
  position: absolute;
  top:10px;
  left: 50%;
  transform: translateX(-50%);
  font-weight: bold;
  display: flex;
  text-align: center;
  flex-direction: column;
}

h1 p {
  font-size: 50%;
}

h2 {
  text-align: center;
}

#github-button {
  position: absolute;
  top: 10px;
  right: 10px;
  display: inline-block;
  background-color: #24292e;
  color: #ffffff;
  text-decoration: none;
  padding: 10px 15px;
  border-radius: 5px;
  font-size: 16px;
  font-weight: 500;
  text-align: center;
  transition: background-color 0.3s ease;
  margin-top: 20px; /* Space above the button */
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.1);
}

#github-button:hover {
  background-color: #444c56; /* Darker shade on hover */
}

table {
  table-layout: fixed;
  width: 100%;
/*  border-collapse: collapse;*/

  border: 2px solid #e0e6ed;
  border-radius: 8px;
  box-shadow: 0 3px 6px rgba(0, 0, 0, 0.05);
  
}

td, tr {
/*  border: 1px solid black;*/
}

td:nth-child(1) {
  margin: 5px;
  border-right: 2px solid #e0e6ed;
}
    </style>
    <title>Plume - TextEngine</title>
</head>

<body>
    <div>
        <h2>Enter your code here</h2>
        <textarea id="input">\macro bold[x] {<strong>$x</strong>}
\macro exemple[x] {
    <table>
        <tr>
            <td>\bold{The code}</td>
            <td>\bold{Gives}</td>
        </tr>
        <tr>
            <td><pre>${x:source()}</pre></td>
            <td><pre>$x</pre></td>
        </tr>
    </table>
}
Welcome to \bold{${plume._VERSION}}.

Plume is a logicfull minimalistic templating langage.

Plume is based on a simple macro system :
\exemple{
    \macro foo bar
    \foo
}

But powerfull :

\exemple {
    \macro double[x] {$x $x}
    \double foo
}

\exemple{
    \macro hello[name=World ?polite] {
        \if $polite {
            Good morning $name.
        }
        \else {
            Yo $name!
        }
    }
    \hello
    \hello[name=sir polite]
}

You can also take the full power of Lua, with simple call:
\exemple {
    1+1 = ${1+1}
    sin of 0.5 is ${math.sin(0.5)}
}

Or inside for and if macro :

\exemple {
    \for ${i=1, 5} {
        \if ${i%2 == 0} {
            $i is odd!
        }
    }
}

Or even with including full lua script!
\exemple {
    ${
        factorial = function (n)
            local result = 1
            for i=1, n do
                result = result * n
            end
            return result
        end
    }

    5! = ${factorial(5)}
}

For some specific case, you can also use Plume inside Lua:

\exemple {
    ${
        a = 5
        b = ${It is a Plume block!}

        if a == 5 then
            return b
        end
    }
}

        </textarea>
    </div>
    <div >
        <h2>Output</h2>
        <!-- <pre id="output"></pre> -->
        <div id="output"></div>
    </div>
    <h1>
        <img src="https://app.barbedor.bzh/plume.png" width="200" height="100">
        <p>Version 0.12.0</p>
    </h1>
    <a id="github-button" href="https://github.com/ErwanBarbedor/Plume_-_TextEngine">
        View on GitHub
    </a>
</body>

<script src="https://cdn.jsdelivr.net/npm/fengari-web@0.1.4/dist/fengari-web.js"></script>

<script type="application/lua">
    local plume_files = {}
local function require (path)
    return plume_files[path] ()
end

plume_files['plume-engine.macros.controls'] = function ()


-- Define for, while, if, elseif, else control structures
return function ()
    local function extract_variables_names (token)
        local result = {}
        local pos = 1

        while pos <= #token do
            local child = token[pos]
            if child.kind == "lua_word" then
                table.insert(result, child.value)
            elseif (child.kind == "lua_code" and (child.value:match('=') or child.value == "in")) then
                break
            end
            pos = pos+1
        end

        return result
    end

    --- \for
    -- Implements a custom iteration mechanism that mimics Lua's for loop behavior.
    -- @param iterator Anything that follow the lua iterator syntax, such as `i=1, 10` or `foo in pairs(t)`.
    -- @param body A block that will be repeated.
    -- @note Each iteration has it's own scope. The maximal number of iteration is limited by `plume.config.max_loop_size`. See [config](config.md) to edit it.
    plume.register_macro("for", {"iterator", "body"}, {join=""}, function(params, calling_token)
        -- The macro uses coroutines to handle the iteration process, which allows for flexible
        -- iteration over various types of iterables without implementing a full Lua parser.
        local result = {}
        local scope = plume.get_scope (calling_token.context)
        local max_loop_size = scope:get("config", "max_loop_size")

        if params.positionnals.iterator.kind ~= "code" then
           plume.error_expecting_an_eval_block (params.positionnals.iterator)
        end
         
        local join = plume.render_if_token(params.keywords.join)

        -- Get iterator code and extract the names of the variables
        local iterator_token = params.positionnals.iterator[2]
        local iterator_code  = iterator_token:source_lua ({}, false, false)
        local variables_list  = extract_variables_names (iterator_token)

        -- Construct a Lua coroutine to handle the iteration
        local coroutine_code = "return coroutine.create(function () for " .. iterator_code .. " do"
        coroutine_code = coroutine_code .. " coroutine.yield(" .. table.concat(variables_list, ",") .. ")"
        coroutine_code = coroutine_code .. " end end)"

        -- Load and create the coroutine
        local iterator_coroutine = plume.load_lua_chunk (coroutine_code)
        if not iterator_coroutine then
            plume.error_syntax_invalid_for_iterator (iterator_token)
        end

        local scope = plume.get_scope (calling_token.context)
        plume.setfenv (iterator_coroutine, scope:bridge_to("variables"))
        local co = iterator_coroutine ()
        
        -- Limiting loop iterations to avoid infinite loop
        local iteration_count  = 0

        -- Main iteration loop
        while true do
            -- Update and check loop limit
            iteration_count = iteration_count + 1
            if iteration_count > max_loop_size then
                plume.error_to_many_loop (calling_token, max_loop_size)
            end

            -- Iteration scope
            plume.push_scope (params.positionnals.body.context)

            -- Resume the coroutine to get the next set of values
            local values_list = { coroutine.resume(co) }
            local sucess = values_list[1]
            table.remove(values_list, 1)
            local first_value = values_list[1]
                
            -- If it not the end of the loop and not the
            -- firt iteration, add the join char
            if first_value then
                if iteration_count > 1 then
                    table.insert(result, join)
                end
            -- And break the loop if there are no more values
            else
                -- exit iteration scope
                plume.pop_scope ()
                break
            end

            -- Check for Lua errors in the coroutine
            if not sucess or not co then
                plume.error(params.positionnals.iterator, "(lua error)" .. first_value:gsub('.-:[0-9]+:', ''))
            end

            -- Verify that the number of variables matches the number of values
            if #values_list ~= #variables_list then
                plume.error(params.positionnals.iterator,
                    "Wrong number of variables, "
                    .. #variables_list
                    .. " instead of "
                    .. #values_list .. "." )
            end

            -- Set local variables in the current scope
            local local_scope = plume.get_scope (calling_token.context)
            for i=1, #variables_list do
                local_scope:set_local ("variables", variables_list[i], values_list[i])
            end

            -- Render the body of the loop and add it to the result
            local body = params.positionnals.body:copy ()
            body:set_context(plume.get_scope(), true)
            table.insert(result, body:render())

            -- exit iteration scope
            plume.pop_scope ()
        end

        return table.concat(result, "")
    end, nil, false, true)

    --- \while
    -- Implements a custom iteration mechanism that mimics Lua's while loop behavior.
    -- @param condition Anything that follow syntax of a lua expression, to evaluate.
    -- @param body A block that will be rendered while the condition is verified.
    -- @note Each iteration has it's own scope. The maximal number of iteration is limited by `plume.config.max_loop_size`. See [config](config.md) to edit it.
    plume.register_macro("while", {"condition", "body"}, {}, function(params, calling_token)
        -- Have the same behavior of the lua while control structure.
        -- To prevent infinite loop, a hard limit is setted by plume.max_loop_size
        local scope = plume.get_scope (calling_token.context)
        local max_loop_size = scope:get("config", "max_loop_size")

        
        local result = {}
        local i = 0

        local condition_code
        if params.positionnals.condition.kind == "code" then
            condition_code  = params.positionnals.condition[2]:source_lua ()
        else
            plume.error_expecting_an_eval_block (params.positionnals.condition)
        end

        while plume.call_lua_chunk (params.positionnals.condition, condition_code) do
            -- Each iteration have it's own local scope
            plume.push_scope (params.positionnals.body.context)
            
            local body = params.positionnals.body:copy ()
            body:set_context(plume.get_scope(), true)
            table.insert(result, body:render())
            i = i + 1
            if i > max_loop_size then
                plume.error_to_many_loop (calling_token, max_loop_size)
            end

            -- exit local scope
            plume.pop_scope ()
        end

        return table.concat(result, "")
    end, nil, false, true)

    --- \if
    -- Implements a custom mechanism that mimics Lua's if behavior.
    -- @param condition Anything that follow syntax of a lua expression, to evaluate.
    -- @param body A block that will be rendered, only if the condition is verified.
    plume.register_macro("if", {"condition", "body"}, {}, function(params, calling_token)
        -- Have the same behavior of the lua if control structure.
        -- Send a message "true" or "false" for activate (or not)
        -- following "else" or "elseif"
        local condition_code

        if params.positionnals.condition.kind == "code" then
            condition_code  = params.positionnals.condition[2]:source_lua ()
        else
            plume.error_expecting_an_eval_block (params.positionnals.condition)
        end

        local condition = plume.call_lua_chunk(params.positionnals.condition, condition_code)
        if condition then
            return params.positionnals.body:render()
        end
        return "", not condition
    end, nil, false, true)

    --- \else
    -- Implements a custom mechanism that mimics Lua's else behavior.
    -- @param body A block that will be rendered, only if the last condition isn't verified.
    -- @note Must follow an `\if` or an `\elseif` macro; otherwise, it will raise an error.
    plume.register_macro("else", {"body"}, {}, function(params, self_token, chain_sender, chain_message)
        -- Must receive a message from preceding if
        if chain_sender ~= "\\if" and chain_sender ~= "\\elseif" then
            plume.error(self_token, "'else' macro must be preceded by 'if' or 'elseif'.")
        end

        if chain_message then
            return params.positionnals.body:render()
        end

        return ""
    end, nil, false, true)

    --- \elseif
    -- Implements a custom mechanism that mimics Lua's elseif behavior.
    -- @param condition Anything that follow syntax of a lua expression, to evaluate.
    -- @param body A block that will be rendered, only if the last condition isn't verified and the current condition is verified.
    -- @note Must follow an `\if` or an `\elseif` macro; otherwise, it will raise an error.
    plume.register_macro("elseif", {"condition", "body"}, {}, function(params, self_token, chain_sender, chain_message)
        -- Must receive a message from preceding if
        if chain_sender ~= "\\if" and chain_sender ~= "\\elseif" then
            plume.error(self_token, "'elseif' macro must be preceded by 'if' or 'elseif'.")
        end

        local condition_token

        if params.positionnals.condition.kind == "code" then
            condition_code  = params.positionnals.condition[2]:source_lua ()
        else
            plume.error_expecting_an_eval_block (params.positionnals.condition)
        end

        local condition
        if chain_message then
            condition = plume.call_lua_chunk(params.positionnals.condition, condition_code)
            if condition then
                return params.positionnals.body:render()
            end
        else
            condition = true
        end
        return "", not condition
    end, nil, false, true)

    --- \do
    -- Implements a custom mechanism that mimics Lua's do behavior.
    -- @param body A block that will be rendered in a new scope.
    plume.register_macro("do", {"body"}, {}, function(params, self_token)
        
        plume.push_scope ()
            local result = params.positionnals.body:render ()
        plume.pop_scope ()

        return result
    end, nil, false, true)
end
end
plume_files['plume-engine.macros.eval'] = function ()


-- Define script-related macro
return function ()
    local function scientific_notation (x, n, sep)
        local n = n or 0
        local sep = sep or "."
        local mantissa = x
        local exposant  = 0

        while mantissa / 10 > 1 do
            mantissa = mantissa / 10
            exposant = exposant + 1
        end

        while mantissa < 1 do
            mantissa = mantissa * 10
            exposant = exposant - 1
        end

        local int_mantissa = math.floor (mantissa)
        local dec_mantissa = mantissa - int_mantissa 
        dec_mantissa = tostring(dec_mantissa):sub(3, n+2)

        mantissa = int_mantissa

        if dec_mantissa ~= "" then
            mantissa = mantissa .. sep .. dec_mantissa
        end

        return mantissa.. "e10^" .. exposant
    end

    local function eval_style (result, format, scinot, d_sep, t_sep, remove_zeros, join_table, table_separator)
        if tonumber(result) then
            if format == "i" then
                local int = math.floor(tonumber(result))
                if result - int >= 0.5 then
                    int = int + 1
                end
                result = int
            elseif format then
                result = string.format("%"..format, result)
            end

            if scinot then
                result = scientific_notation (result, scinot, t_sep)
            else
                local int, dec = tostring(result):match('^(.-)%.(.+)')
                if not dec then
                    int = tostring(result)
                end

                if t_sep then
                    local e_t_sep = t_sep:gsub('.', '%%%1')--escaped for matching pattern

                    int = int:gsub('([0-9])([0-9][0-9][0-9])$', '%1' .. t_sep .. '%2')
                    while int:match('[0-9][0-9][0-9][0-9]' .. e_t_sep) do
                        int = int:gsub('([0-9])([0-9][0-9][0-9])' .. e_t_sep, '%1' .. t_sep .. '%2' .. t_sep)
                    end
                end

                if dec and not (remove_zeros and dec:match('^0+$')) then
                    result = int .. d_sep .. dec
                else
                    result = int
                end
            end

            if remove_zeros then
                result = tostring(result):gsub("%"..d_sep..'([0-9]-)0+$', "%"..d_sep.."%1")
            end
        elseif type(result) == "table" and join_table then
            local table_result = {}

            for i, x in ipairs(result) do
                table_result[i] = eval_style (x, format, scinot, d_sep, t_sep, remove_zeros)
            end

            result = table.concat(table_result, table_separator)
        end

        return result
    end

    --- \eval
    -- Evaluate the given expression or execute the given statement.
    -- @param code The code to evaluate or execute.
    -- @option thousand_separator={} Symbol used between groups of 3 digits.
    -- @option decimal_separator=. Symbol used between the integer and the decimal part.
    -- @option join=_ If the value is a table, string to put between table elements.
    -- @option_nokw format={} Only works if the code returns a number. If `i`, the number is rounded. If `.2f`, it will be output with 2 digits after the decimal point. If `.3s`, it will be output using scientific notation, with 3 digits after the decimal point.
    -- @flag remove_zeros Remove useless zeros (e.g., `1.0` becomes `1`).
    -- @flag silent Execute the code without returning anything. Useful for filtering unwanted function returns: `${table.remove(t)}[silent]`
    -- @flag no_join_table Doesn't render all table element and just return `tostring(table)`.
    -- @alias `${1+1}` is the same as `\eval{1+1}`
    -- @note If the given code is a statement, it cannot return any value.
    -- @note In some case, plume will treat a statement given code as an expression. To forced the detection by plume, start the code with a comment.
    plume.register_macro("eval", {"expr"}, {thousand_separator="", decimal_separator=".", join=" "}, function(params, calling_token)
        local remove_zeros, format, scinot, silent
        local join_table = true

        for _, flag in ipairs(params.others.flags) do
            if flag == "remove_zeros" then
                remove_zeros = true
            elseif flag == "no_join_table" then
                join_table = false
            elseif flag == "silent" then
                silent = true
            elseif flag:match('%.[0-9]+f') or flag == "i" then
                format = flag
            elseif not scinot and flag:match('%.[0-9]+s') then
                scinot = flag:match('%.([0-9]+)s')
            else
                plume.error(calling_token, "Unknow arg '" .. flag .. "'.")
            end
        end


        --Get separator if provided
        local t_sep, d_sep
        
        t_sep = plume.render_if_token(params.keywords.thousand_separator)
        if t_sep and #t_sep == 0 then t_sep = nil end
        d_sep = plume.render_if_token(params.keywords.decimal_separator)
        table_separator = plume.render_if_token(params.keywords.join)

        local result = plume.call_lua_chunk(params.positionnals.expr)

        -- if result is a token, render it
        if type(result) == "table" and result.render then
            result = result:render ()
        end

        -- Applying style
        result = eval_style (result, format, scinot, d_sep, t_sep, remove_zeros, join_table, table_separator)
        
        if not silent then
            return result
        end
    end, nil, false, true, true)
end
end
plume_files['plume-engine.macros.files'] = function ()


-- Define macro related to files
return function ()
    --- Search path and open file
    -- @param token token Token used to throw an error (optionnal)
    -- @param formats table List of path formats to try (e.g., {"?.lua", "?/init.lua"})
    -- @param path string Path of the file to search for
    -- @param mode string mode to open file into. Defaut "r".
    -- @param silent_fail bool If true, doesn't raise an error if not file found.
    -- @return file file File descriptor of the found file
    -- @return filepath string Full path of the found file
    -- @raise Throws an error if the file is not found, with a message detailing the paths tried
    function plume.open (token, formats, path, mode, silent_fail)
        -- To avoid checking same folder two times
        local parent
        local folders     = {}
        local tried_paths = {}

        -- Find the path relative to each parent
        local parent_paths = {}

        for i=#plume.traceback, 1, -1 do
            local file = plume.traceback[i].file
            local dir  = file:gsub('[^\\/]*$', ''):gsub('[\\/]$', '')

            if not parent_paths[dir] then
                parent_paths[dir] = true
                table.insert(parent_paths, dir)
            end
        end

        if plume.directory then
            table.insert(parent_paths, plume.directory .. "/lib")
        end

        local file, filepath
        for _, folder in ipairs(parent_paths) do
            
            -- "/path" isn't a valid path, so if not a parent folder,
            -- simply use "path"
            if folder ~= "" then
                folder = folder .. "/"
            end

            for _, format in ipairs(formats) do
                filepath = format:gsub('?', path)
                filepath = (folder.. filepath)
                -- filepath = filepath:gsub('^/', '')
                
                file, msg = io.open(filepath, mode)

                if file then
                    break
                else
                    table.insert(tried_paths, filepath)
                end
            end

            if file then
                break
            end
        end

        if not file then
            local msg = "File '" .. path .. "' doesn't exist or cannot be read."
            msg = msg .. "\nTried: "
            for _, path in ipairs(tried_paths) do
                msg = msg .. "\n\t" .. path
            end
            msg = msg .. "\n"
            if silent_fail then
                return nil, nil, msg
            else
                plume.error(token or plume.traceback[i], msg)
            end
        end

        return file, filepath
    end

    --- \require
    -- Execute a Lua file in the current scope.
    -- @param path Path of the file to require. Use the plume search system: first, try to find the file relative to the file where the macro was called. Then relative to the file of the macro that called `\require`, etc... If `name` was provided as path, search for files `name`, `name.lua` and `name/init.lua`.
    -- @note Unlike the Lua `require` function, `\require` macro does not perform any caching.
    plume.register_macro("require", {"path"}, {}, function(params, calling_token)
        local path = params.positionnals.path:render ()

        local formats = {}
        
        if path:match('%.[^/][^/]-$') then
            table.insert(formats, "?")
        else
            table.insert(formats, "?.lua")
            table.insert(formats, "?/init.lua") 
        end

        local file, filepath = plume.open (params.positionnals.path, formats, path)

        -- Render file content
        local content = file:read("*a")

        if content == nil then
            plume.error(params.positionnals["$path"], "This path exists, but has no content. This may be a directory.")
        end

        local f = plume.call_lua_chunk (calling_token, "return function ()\n" .. content .. "\n end", filepath)

        return f()
    end, nil, false, true)

    --- \include
    -- Execute a plume file in the current scope.
    -- @param path Path of the file to include. Use the plume search system: first, try to find the file relative to the file where the macro was called. Then relative to the file of the macro that called `\require`, etc... If `name` was provided as path, search for files `name`, `name.plume` and `name/init.plume`.
    -- @other_options Any argument will be accessible from the included file, in the field `__file_params`.
    plume.register_macro("include", {"$path"}, {}, function(params, calling_token)
        --  Execute the given file and return the output
        local path = params.positionnals["$path"]:render ()

        local formats = {}
        
        table.insert(formats, "?.plume")
        table.insert(formats, "?/init.plume")
        table.insert(formats, "?")  

        local file, filepath = plume.open (params.positionnals["$path"], formats, path)

        -- file scope
        plume.push_scope ()

            --- @scope_variable __file_params Work as `__params`, but inside a file imported by using `\\include`
            local __file_params = {}

            for k, v in pairs(params.others.keywords) do
                __file_params[k] = v
            end

            for _, k in ipairs(params.others.flags) do
                __file_params[k] = true
            end

            local scope = plume.get_scope (calling_token.context)
            scope:set_local("variables", "__file_params", __file_params)

            -- Render file content
            local content = file:read("*a")

            if content == nil then
                plume.error(params.positionnals["$path"], "This path exists, but has no content. This may be a directory.")
            end

            local result = plume.render(content, filepath)

        -- Exit from file scope
        plume.pop_scope ()

        return result
    end, nil, false, true, true)

    --- \extern
    -- Insert content of the file without execution. Quite similar to `\raw`, but for a file.
    -- @param path Path of the file to include. Use the plume search system: first, try to find the file relative to the file where the macro was called. Then relative to the file of the macro that called `\require`, etc... 
    plume.register_macro("extern", {"path"}, {}, function(params, calling_token)
        -- Include a file without execute it

        local path = params.positionnals.path:render ()

        local formats = {}
        
        table.insert(formats, "?")

        local file, filepath = plume.open (params.positionnals.path, formats, path)

        return file:read("*a")
    end, nil, false, true)

    --- \file
    -- Render a plume chunck and save the output in the given file.
    -- @param path Name of the file to write.
    -- @param note Content to write in the file.
    plume.register_macro("file", {"path", "content"}, {}, function (params, calling_token)
        -- Capture content and save it in a file.
        -- Return nothing.
        -- \file {foo.txt} {...}
        local path = params.positionnals.path:render ()
        local file = io.open(path, "w")

            if not file then
                plume.error (calling_token, "Cannot write file '" .. path .. "'")
            end

            local content = params.positionnals.content:render ()
            file:write(content)

        file:close ()

        return ""

    end, nil, false, true)
end
end
plume_files['plume-engine.macros.macros'] = function ()


-- Define macro-related macros
return function ()
    --- Checks if a macro is already defined in the current scope and issues a warning if it is.
    -- @param token tokenlist
    -- @param name string The name of the macro to check.
    local function check_macro_availability(token, name)
        -- Retrieve the current scope based on the context provided by the token
        local scope = plume.get_scope(token.context)
        
        -- Attempt to get the macro by name from the current scope
        local macro = scope:get("macros", name)
        
        -- Get the configuration setting for showing macro overwrite warnings
        local show_macro_overwrite_warnings = scope:get("config", "show_macro_overwrite_warnings")
        
        -- If the macro is already defined and warnings are enabled, issue a warning
        if macro and show_macro_overwrite_warnings then
            plume.warning_macro_already_exists(token, macro)
        end
    end


    --- Defines a new macro or redefines an existing one.
    -- @param def_parameters table The arguments for the macro definition
    -- @param is_local boolean Whether the macro is local
    -- @param calling_token token The token where the macro is being defined
    local function new_macro (macro_parameters, is_local, calling_token)
        -- Get the provided macro name
        local name = macro_parameters.positionnals.name:render()
        local variable_parameters_number = false

        local scope  = plume.get_scope(calling_token.context)

        -- Check if the name is a valid identifier
        if not plume.is_identifier(name) then
            plume.error_invalid_name (macro_parameters.positionnals.name, name, "macro")
        end

        -- If define globaly, check if a macro with this name already exist
        if not is_local then
            check_macro_availability (macro_parameters.positionnals.name, name)
        end

        -- Check if parameters names are valid and register flags
        for name, _ in pairs(macro_parameters.others.keywords) do
            if not plume.is_identifier(name) then
                plume.error_invalid_name (calling_token, name, "parameter")
            end
        end

        local parameters_names = {}
        for _, name in ipairs(macro_parameters.others.flags) do
            if name == "..." then
                variable_parameters_number = true
            else
                local flag = false
                if name:sub(1, 1) == "?" then
                    name = name:sub(2, -1)
                    flag = true
                end
                if not plume.is_identifier(name) then
                    plume.error(calling_token, "'" .. name .. "' is an invalid parameter name.")
                end
                if flag then
                    macro_parameters.others.keywords[name] = false
                else
                    table.insert(parameters_names, name)
                end
            end
        end

        -- Capture current scope
        local closure = plume.get_scope ()
        
        plume.register_macro(name, parameters_names, macro_parameters.others.keywords, function(params, calling_token, chain_sender, chain_message)
            -- Insert closure
            plume.push_scope (closure)

            -- Copy all tokens. Then, give each of them
            -- a reference to current lua scope
            -- (affect only scripts and evals tokens)
            local last_scope = plume.get_scope ()
            for k, v in pairs(params.positionnals) do
                params.positionnals[k] = v:copy ()
                params.positionnals[k]:set_context (last_scope)
            end
            for k, v in pairs(params.keywords) do
                if type(params.keywords[k]) == "table" then
                    params.keywords[k] = v:copy ()
                    params.keywords[k]:set_context (last_scope)
                end
            end

            --- @scope_variable __params When inside a macro with a variable paramter count, contain all excedents parameters, use `pairs` to iterate over them. Flags are both stocked as key=value (`__params.some_flag = true`) and table indice. (`__params[1] = "some_flag"`|
            local __params = {}
            for k, v in pairs(params.others.keywords) do
                if type(params.others.keywords[k]) == "table" then
                     __params[k] = v:copy ()
                     __params[k]:set_context (last_scope)
                end
            end
            for i, k in ipairs(params.others.flags) do
                __params[k] = true
                __params[i] = k
            end

            
            -- argument are variable local to the macro
            local scope = plume.push_scope ()

            -- add all params in the current scope
            for k, v in pairs(params.positionnals) do
                scope:set_local("variables", k, v)
            end
            for k, v in pairs(params.keywords) do
                scope:set_local("variables", k, v)
            end
            for _, k in pairs(params.flags) do
                scope:set_local("variables", k, true)
            end

            scope:set_local("variables", "__params", __params)

            --- @scope_variable __message  Used to implement if-like behavior. If you give a value to `__message.send`, the next macro to be called (in the same block) will receive this value in `__message.content`, and the name for the last macro in `__message.sender` 
            
            scope:set_local("variables", "__message", {sender = chain_sender, content = chain_message})

            local body = macro_parameters.positionnals.body:copy ()
            body:set_context (scope, true)
            local result = body:render()

            -- Capture message
            local message = scope:get("variables", "__message")
            -- exit macro scope
            plume.pop_scope ()

            -- exit closure
            plume.pop_scope ()

            return result, tostring(message.send)
        end, calling_token, is_local, false, variable_parameters_number)
    end

    --- \macro
    -- Define a new macro.
    -- @param name Name must be a valid lua identifier
    -- @param body Body of the macro, that will be render at each call.
    -- @other_options Macro arguments names. See [more about](advanced.md#macro-parameters)
    -- @note Doesn't work if the name is already taken by another macro.
    plume.register_macro("macro", {"name", "body"}, {}, function(def_parameters, calling_token)
        -- '$' in arg name, so they cannot be erased by user
        new_macro (def_parameters, false, calling_token)
        return ""
    end, nil, false, true, true)

    --- \local_macro
    -- Define a new macro locally.
    -- @param name Name must be a valid lua identifier
    -- @param body Body of the macro, that will be render at each call.
    -- @other_options Macro arguments names.
    -- @alias `\macrol`
    plume.register_macro("local_macro", {"name", "body"}, {}, function(def_parameters, calling_token)
        -- '$' in arg name, so they cannot be erased by user
        new_macro (def_parameters, true, calling_token)
        return ""
    end, nil, false, true, true)

    --- \lmacro
    -- Alias for [local_macro](#local_macro)
    -- @param name Name must be a valid lua identifier
    -- @param body Body of the macro, that will be render at each call.
    -- @other_options Macro arguments names.
    plume.register_macro("lmacro", {"name", "body"}, {}, function(macro_parameters, calling_token)
        -- '$' in arg name, so they cannot be erased by user
        new_macro (macro_parameters, true, calling_token)
        return ""
    end, nil, false, true, true)

    --- Create alias of a function
    local function alias (name1, name2, calling_token, is_local)
        -- Test names availability
        local scope =  plume.get_scope (calling_token.context)

        if not scope:get("macros", name1) then
            plume.error(calling_token, "The macro '" .. name2 .. "' doesn't exists, so \\alias failed.")
        end
        if not is_local then
            check_macro_availability (calling_token, name2)
        end

        local macro = scope.macros[name1]
        if is_local then
            scope:set_local("macros", name2, macro)
        else
            scope:set("macros", name2, macro) 
        end
    end

    --- \alias
    -- name2 will be a new way to call name1.
    -- @param name1 Name of an existing macro.
    -- @param name2 Any valid lua identifier.
    -- @flag local Is the new macro local to the current scope.
    plume.register_macro("alias", {"name1", "name2"}, {}, function(params, calling_token)
        local name1 = params.positionnals.name1:render()
        local name2 = params.positionnals.name2:render()
        alias (name1, name2, calling_token, false)
    end, nil, false, true)

    --- \local_alias
    -- Make an alias locally
    -- @param name1 Name of an existing macro.
    -- @param name2 Any valid lua identifier.
    -- @alias `\lalias`
    plume.register_macro("local_alias", {"name1", "name2"}, {}, function(params, calling_token)
        local name1 = params.positionnals.name1:render()
        local name2 = params.positionnals.name2:render()
        alias (name1, name2, calling_token, true)
    end, nil, false, true)

    --- \lalias
    -- Alias for [local_alias](#local_alias)
    -- @param name1 Name of an existing macro.
    -- @param name2 Any valid lua identifier.
    plume.register_macro("lalias", {"name1", "name2"}, {}, function(params, calling_token)
        local name1 = params.positionnals.name1:render()
        local name2 = params.positionnals.name2:render()
        alias (name1, name2, calling_token, true)
    end, nil, false, true)

    --- Set (or reset) default parameters of a given macro.
    -- @param token table The calling token
    -- @param name string The name of the macro.
    -- @param keywords table A table of keyword arguments to set as default.
    -- @param flags table A list of flags to set as default.
    -- @param is_local boolean Is the default value local or global
    local function default(token, name, keywords, flags, is_local)
        local scope = plume.get_scope(token.context)
        local macro = scope:get("macros", name)

        -- Warning if edit "eval"
        if name == "eval" and not is_local then
            if scope:get("config", "show_beginner_warnings") then
                plume.warning_using_global_default_on_eval (token)
            end
        end

        -- Check if this macro exists
        if not macro then
            plume.error_macro_not_found(token, name)
        end

        -- Register keyword params and flags.
        local other_keywords = {}
        
        for k, v in pairs(keywords) do
            local name = tostring(macro) .. "@" .. k

            if macro.default_opt_params[k] then
                if is_local then
                    scope:set_local("default", name, v)
                else
                    scope:set("default", name, v)
                end
            else
                other_keywords[k] = v
            end
        end
        
        local other_flags = {}
        for _, k in ipairs(flags) do
            local name  = tostring(macro) .. "@" .. k

            if macro.default_opt_params[k] then
                if is_local then
                    scope:set_local("default", name, true)
                else
                    scope:set("default", name, true)
                end
            else
                table.insert(other_flags, k)
            end
        end

        if #other_keywords>0 then
            local name = tostring(macro) .. "?keywords"
            if is_local then
                scope:set_local("default", name, other_keywords)
            else
                scope:set("default", name, other_keywords)
            end
        end

        if #other_flags>0 then
            local name = tostring(macro) .. "?flags"
            if is_local then
                scope:set_local("default", name, other_flags)
            else
                scope:set("default", name, other_flags)
            end
        end
    end


    --- \default
    -- set (or reset) default params of a given macro.
    -- @param name Name of an existing macro.
    -- @other_options Any parameters used by the given macro.
    plume.register_macro("default", {"name"}, {}, function(params, calling_token)
        local name = params.positionnals.name:render()
        default (calling_token, name, params.others.keywords, params.others.flags, false)
    end, nil, false, true, true)

    --- \local_default
    -- set  localy (or reset) default params of a given macro.
    -- @param name Name of an existing macro.
    -- @other_options Any parameters used by the given macro.
    -- @alias `\ldefault`
    plume.register_macro("local_default", {"name"}, {}, function(params, calling_token)
        local name = params.positionnals.name:render()
        default (calling_token, name, params.others.keywords, params.others.flags, true)

    end, nil, false, true, true)

    --- \ldefault
    -- alias for [local_default](#local_default).
    -- @param name Name of an existing macro.
    -- @other_options Any parameters used by the given macro.
    plume.register_macro("ldefault", {"name"}, {}, function(params, calling_token)
        local name = params.positionnals.name:render()
        default (calling_token, name, params.others.keywords, params.others.flags, true)

    end, nil, false, true, true)
end
end
plume_files['plume-engine.macros.spaces'] = function ()


-- Define spaces-related macros
return function ()
    --- \n
    -- Output a newline. 
    -- @option_nokw n=1 Number of newlines to output.
    -- @note Don't affected by `plume.config.filter_spaces` and `plume.config.filter_newlines`.
    plume.register_macro("n", {}, {}, function(params)
        local count = 1
        if params.others.flags[1] then
            count = params.others.flags[1]
        end
        return ("\n"):rep(count)
    end, nil, false, true, true)

    --- \s
    -- Output a space.
    -- @option_nokw n=1 Number of spaces to output.
    -- @note Don't affected by `plume.config.filter_spaces` and `plume.config.filter_newlines`.
    plume.register_macro("s", {}, {}, function(params)
        local count = 1
        if params.others.flags[1] then
            count = params.others.flags[1]
        end
        return (" "):rep(count)
    end, nil, false, true, true)

    --- \t
    -- Output a tabulation.
    -- @option_nokw n=1 Number of tabs to output.
    -- @note Don't affected by `plume.config.filter_spaces` and `plume.config.filter_newlines`.
    plume.register_macro("t", {}, {}, function(params)
        local count = 1
        if params.others.flags[1] then
            count = params.others.flags[1]
        end
        return ("\t"):rep(count)
    end, nil, false, true, true)

    --- \set_space_mode
    -- Shortand for common value of `plume.config.filter_spaces` and `plume.config.filter_newlines` (see [config](config.md)).
    -- @param mode Can be `normal` (take all spaces), `no_spaces` (ignore all spaces), `compact` (replace all space/tabs/newlines sequence with " ") and `light` (replace all space sequence with " ", all newlines block with a single `\n`)
    plume.register_macro("set_space_mode", {"mode"}, {}, function(params, calling_token)
        local mode = params.positionnals.mode:render ()
        local scope = plume.get_scope(calling_token.context)

        if mode == "normal" then
            scope:set("config", "filter_spaces", false)
            scope:set("config", "filter_newlines", false)
        elseif mode == "no_spaces" then
            scope:set("config", "filter_spaces", "")
            scope:set("config", "filter_newlines", "")
        elseif mode == "compact" then
            scope:set("config", "filter_spaces", " ")
            scope:set("config", "filter_newlines", " ")
        elseif mode == "light" then
            scope:set("config", "filter_spaces", " ")
            scope:set("config", "filter_newlines", "\n")
        else
            plume.error(params.mode, "Unknow value space mode '" .. mode .. "'. Accepted values are : normal, no_spaces, light.")
        end
    end)
end
end
plume_files['plume-engine.macros.utils'] = function ()


-- Define some useful macro like set, raw, config, ...

return function ()
    --- Affect a value to a variable
    local function set(params, calling_token, is_local)
        -- A macro to set variable to a value
        local key = params.positionnals.key:render()
        if not plume.is_identifier(key) then
            plume.error(params.positionnals.key, "'" .. key .. "' is an invalid name for a variable.")
        end

        local value = params.positionnals.value:render ()
        local scope = plume.get_scope(calling_token.context)

        if is_local then
            scope:set_local("variables", key, value)
        else
            scope:set("variables", key, value) 
        end
    end

    --- \set
    -- Affect a value to a variable.
    -- @param key The name of the variable.
    -- @param value The value of the variable.
    -- @note Value is always stored as a string. To store lua object, use `#{var = ...}`
    plume.register_macro("set", {"key", "value"}, {}, function(params, calling_token)
        set(params, calling_token, false)
        return ""
    end, nil, false, true)

    --- \local_set
    -- Affect a value to a variable locally.
    -- @param key The name of the variable.
    -- @param value The value of the variable.
    -- @note Value is always stored as a string. To store lua object, use `#{var = ...}`
    -- @alias `lset`
    plume.register_macro("local_set", {"key", "value"}, {}, function(params, calling_token)
        set(params, calling_token, true)
        return ""
    end, nil, false, true)

    --- lset
    -- Alias for [local_set](#local_set)
    -- @param key The name of the variable.
    -- @param value The value of the variable.
    -- @note Value is always stored as a string. To store lua object, use `#{var = ...}`
    plume.register_macro("lset", {"key", "value"}, {}, function(params, calling_token)
        set(params, calling_token, true)
        return ""
    end, nil, false, true)

    --- \raw
    -- Return the given body without render it.
    -- @param body 
    plume.register_macro("raw", {"body"}, {}, function(params)
        return params.positionnals['body']:source ()
    end, nil, false, true)

    --- \config
    -- Edit plume configuration.
    -- @param key Name of the parameter.
    -- @param value New value to save.
    -- @note Will raise an error if the key doesn't exist. See [config](config.md) to get all available parameters.
    plume.register_macro("config", {"name", "value"}, {}, function(params, calling_token)
        local name   = params.positionnals.name:render ()
        local value  = params.positionnals.value:render_lua ()
        local scope = plume.get_scope()

        if scope.config[name] == nil then
            plume.error (calling_token, "Unknow configuration entry '" .. name .. "'.")
        end

        scope:set("config", name, value)
    end, nil, false, true)

    --- \lconfig
    -- Edit plume configuration in local scope.
    -- @param key Name of the parameter.
    -- @param value New value to save.
    -- @note Will raise an error if the key doesn't exist. See [config](config.md) to get all available parameters.
    plume.register_macro("lconfig", {"name", "value"}, {}, function(params, calling_token)
        local name   = params.positionnals.name:render ()
        local value  = params.positionnals.value:render_lua ()
        local scope = plume.get_scope(calling_token.context)

        if scope.config[name] == nil then
            plume.error (calling_token, "Unknow configuration entry '" .. name .. "'.")
        end
        
        scope:set_local("config", name, value)
    end, nil, false, true)

    function plume.deprecate (name, version, alternative, calling_token)
        local scope = plume.get_scope ()
        local macro = scope:get("macros", name)

        if not macro then
            return nil
        end

        local macro_f = macro.macro

        macro.macro = function (params, calling_token)
            local scope = plume.get_scope (calling_token.context)
            local show_deprecation_warnings = scope:get("config", "show_deprecation_warnings")
            if show_deprecation_warnings then
                plume.warning_deprecated_macro (calling_token, name, version, alternative)
            end

            return macro_f (params, calling_token)
        end

        return true
    end

    --- \deprecate
    -- Mark a macro as "deprecated". An error message will be printed each time you call it, except if you set `plume.config.show_deprecation_warnings` to `false`.
    -- @param name Name of an existing macro.
    -- @param version Version where the macro will be deleted.
    -- @param alternative Give an alternative to replace this macro.
    plume.register_macro("deprecate", {"name", "version", "alternative"}, {}, function(params, calling_token)
        local name        = params.positionnals.name:render()
        local version     = params.positionnals.version:render()
        local alternative = params.positionnals.alternative:render()

        if not plume.deprecate(name, version, alternative) then
            plume.error_macro_not_found(params.positionnals.name, name)
        end

    end, nil, false, true)
end
end
plume_files['plume-engine.messages.errors'] = function ()


-- Function to make error messages in specific cases

--- Compute Damerau-Levenshtein distance
-- @param s1 string first word to compare
-- @param s2 string second word to compare
-- @return int Damerau-Levenshtein distance bewteen s1 and s2
local function word_distance(s1, s2)
    
    local len1, len2 = #s1, #s2
    local matrix = {}

    for i = 0, len1 do
        matrix[i] = {[0] = i}
    end
    for j = 0, len2 do
        matrix[0][j] = j
    end

    for i = 1, len1 do
        for j = 1, len2 do
            local cost = (s1:sub(i,i) ~= s2:sub(j,j)) and 1 or 0
            matrix[i][j] = math.min(
                matrix[i-1][j] + 1,
                matrix[i][j-1] + 1,
                matrix[i-1][j-1] + cost
            )
            if i > 1 and j > 1 and s1:sub(i,i) == s2:sub(j-1,j-1) and s1:sub(i-1,i-1) == s2:sub(j,j) then
                matrix[i][j] = math.min(matrix[i][j], matrix[i-2][j-2] + cost)
            end
        end
    end

    return matrix[len1][len2]
end

--- Convert an associative table to an alphabetically sorted one.
-- @param t table The associative table to sort
-- @return table The table containing sorted keys
local function sort(t)
    -- Create an empty table to store the sorted keys
    local sortedTable = {}
    
    -- Extract keys from the associative table
    for k in pairs(t) do
        table.insert(sortedTable, k)
    end

    -- Sort the keys alphabetically
    table.sort(sortedTable)
    
    return sortedTable
end

--- Initialize the combination table
-- @param n number The size of the combination table
-- @return table A table initialized with values from 1 to n
local function init_comb(n)
    local t = {}
    for i = 1, n do
        table.insert(t, i)
    end
    return t
end

--- Increment the combination
-- @param t table The current combination table
-- @param n number The maximum allowable number in the combination
-- @param i number The current index to increment, defaults to the length of t if not provided
-- @return boolean Returns true if the operation was successful, else returns nil
local function inc_comb(t, n, i)
    i = i or #t
    t[i] = t[i] + 1

    -- Normalize the current index if it exceeds the maximum number
    if t[i] > n then
        t[i] = 1
        if i == 1 then
            return
        end
        if not inc_comb(t, n, i - 1) then
            return
        end
    end

    -- Ensure no duplicate numbers exist in the combination
    for j = 1, i - 1 do
        if t[j] == t[i] then
            return inc_comb(t, n, i)
        end
    end

    return true
end

--- Iterator function for generating combinations
-- @param n number The size of the combination
-- @return function A function that, when called, returns the next combination table or nil if done
local function iter_comb(n)
    local t = init_comb(n)
    return function()
        if inc_comb(t, n) then
            return t
        end
    end
end


--- Generates error message for error occuring in plume internal functions
-- @param error_message string The error message
function plume.internal_error (error_message)
    -- Get the plume line that caused the error
    for line in debug.traceback ():gmatch('[^\n]+') do
        local line_error = line:match('^%s*%[string "%-%-chunk[0-9]+%.%.%."%]:[0-9]+:')
        if line_error then
            error_message = line_error .. " " .. error_message
            break
        end
    end

    plume.error(plume.lua_cache[#plume.lua_cache], error_message, true)
end

--- Checks and corrects the order of words in a name based on scope.
-- @param name string The name to be checked and potentially corrected.
-- @param scope string The scope to determine the correct order of words.
-- @return string The name with the correct word order based on the given scope.
function test_word_order(name, scope)
    local result = {}

    for _, config in ipairs({
            {pattern="[^_]+",         sep="_"},
            {pattern="[A-Z]-[^A-Z]+", sep="", lower_first=true, upper_second=true}
        }) do
        local words = {}
        for word in name:gmatch(config.pattern) do
            table.insert(words, word)
        end
        
        for comb in iter_comb(#words) do
            local suggestion = {}
            for i, k in ipairs(comb) do
                local word = words[k]
                if config.lower_first and i==1 then
                    word = word:sub(1, 1):lower() .. word:sub(2, -1)
                elseif config.upper_second and i>1 then
                    word = word:sub(1, 1):upper() .. word:sub(2, -1)
                end

                table.insert(suggestion, word)
            end

            local suggestion = table.concat(suggestion, config.sep)
            if scope:get("macros", suggestion) then
                table.insert(result, suggestion)
            end
        end
    end

    return result
end

--- Generates error message for macro not found.
-- @param token table The token that caused the error (optional)
-- @param macro_name string The name of the not founded macro
function plume.error_macro_not_found (token, macro_name)
    
    -- Use a table to avoid duplicate names
    local suggestions_table = {}

    local scope = plume.get_scope(token and token.context)
    
    -- Hardcoded suggestions for common errors
    if macro_name == "import" then
        suggestions_table["require"] = true
        suggestions_table["include"] = true
    elseif macro_name == "def" or macro_name == "function" or macro_name == "func" then
        suggestions_table.macro = true
    elseif macro_name == "script" or macro_name == "lua" then
        suggestions_table.eval = true
        suggestions_table['$'] = true
    end

    -- Suggestions for possible typing errors
    
    -- Character suppressions or substitutions, like using "foo" instead of "foo"
    for _, name in ipairs(scope:get_all("macros")) do
        if word_distance (name, macro_name) <= math.max(math.min(3, #macro_name - 2), 1) then
            suggestions_table[name] = true
        end
    end
    -- Wrong word order, like using "local_macro" instead of "macro_local"
    for _, name in ipairs(test_word_order(macro_name, scope)) do
        suggestions_table[name] = true
    end

    local suggestions_list = sort(suggestions_table)
    for i, name in ipairs(suggestions_list) do
        suggestions_list[i] =  "'" .. name .."'"
    end

    local msg = "Unknow macro '" .. macro_name .. "'."

    if #suggestions_list > 0 then
        msg = msg .. " Perhaps you mean "
        msg = msg .. table.concat(suggestions_list, ", "):gsub(',([^,]*)$', " or%1")
        msg = msg .. "?"
    end

    plume.error (token, msg)
end

--- Generates an error message for unknown optional parameters not found.
-- @param token table The token that caused the error (optional)
-- @param macro_name string The name of the called macro during the error
-- @param parameter string The name of the not found macro
-- @param valid_parameters table Table of valid parameter names
function plume.error_unknown_parameter (token, macro_name, parameter, valid_parameters)
    -- Use a table to avoid duplicate names
    local suggestions_table = {}

    -- Suggestions for possible typing errors
    for name, _ in pairs(valid_parameters) do
        if word_distance (name, parameter) <= math.max(math.min(3, #parameter - 2), 1) then
            suggestions_table[name] = true
        end
    end

    local suggestions_list = sort(suggestions_table)-- To make the order deterministic
    for i, name in ipairs(suggestions_list) do
        suggestions_list[i] =  "'" .. name .."'"
    end

    local msg = "Unknow optionnal parameter '" .. parameter .. "' for macro '" .. macro_name .. "'."

    if #suggestions_list > 0 then
        msg = msg .. " Perhaps you mean "
        msg = msg .. table.concat(suggestions_list, ", "):gsub(',([^,]*)$', " or%1")
        msg = msg .. "?"
    end

    plume.error (token, msg)
end

--- Handles error when the end of a block is reached.
-- This function is used to report an error when a macro does not receive the expected number of arguments.
-- @param token table The token associated with the macro call.
-- @param x number The number of arguments received.
-- @param y number The number of arguments expected.
function plume.error_end_block_reached(token, x, y)
    local msg = "End of block reached, not enough arguments for macro '" .. token.value .. "'. "
    msg = msg .. x .. " instead of " .. y .. "."

    plume.error(token, msg)
end

function plume.error_macro_call_without_braces (macro_token, token, n)
    local msg = "Macro call cannot be a parameter"
    msg = msg .. " (here, parameter #"
        msg = msg .. n
        msg = msg .. " of the macro '"
        msg = msg .. macro_token.value
        msg = msg .. "', line "
        msg = msg .. macro_token.line
    msg = msg .. ") "
    msg = msg .. "without being surrounded by braces."

    plume.error(token, msg)
end

function plume.error_invalid_name (token, name, kind)
    plume.error(token, "'" .. name .. "' is an invalid name for a " .. kind .. ".")
end

function plume.error_expecting_an_eval_block (param)
    local source = param:source()
    local correct_source = source

    local msg = "This parameter must be an eval block. "
    if source:sub(1, 1) ~= "{" then
        correct_source = "{" .. correct_source
    end

    if source:sub(-1, -1) ~= "}" then
        correct_source = correct_source .. "}" 
    end

    msg = msg .. "Write '$" .. correct_source .. "' "
    msg = msg .. "instead of '" .. source .. "' "

    plume.error(param, msg)
end


function plume.error_to_many_loop (token, max_loop_size)
    plume.error(token, "To many loop repetition (over the configurated limit of " .. max_loop_size .. ").")
end
end
plume_files['plume-engine.messages.syntax_errors'] = function ()



function plume.syntax_error_wrong_eval (token, char)
    local msg = "Syntax error : '" .. plume.syntax.eval .. "' must be followed by an identifier "
    msg = msg .. "or '" .. plume.syntax.block_begin .. "', "
    msg = msg .. "not '" .. char .. "'."
    plume.error (token,  msg)
end

function plume.syntax_error_wrong_eval_inside_lua (token, char)
    local msg = "Syntax error : inside a lua bloc, '" .. plume.syntax.eval .. "' must be followed by '" .. plume.syntax.block_begin .. "', "
    msg = msg .. "not '" .. char .. "'."
    plume.error (token,  msg)
end

function plume.syntax_error_brace_close_nothing (token)
    plume.error(token, "Syntax error : this brace close nothing.")
end

function plume.syntax_error_wrong_block_end (token, opening)
    local braces = "%[%]{}"

    local escaped_opening = opening:gsub('([%%%^%$%(%)%.%[%]%*%+%-%?])', '%%%1')
    local escaped_token_source = token:source():gsub('([%%%^%$%(%)%.%[%]%*%+%-%?])', '%%%1')
    if braces:match(escaped_opening) and braces:match(escaped_token_source) then
        plume.syntax_error_unpaired_braces (token, opening)
    elseif ("if elseif do for while function"):match(escaped_opening) then
        plume.syntax_error_lua_missing_end (token, opening)
    else
        plume.error(token, "Syntax error : this is an unexpected way to close '"..opening.."'.")
    end
end


function plume.syntax_error_unpaired_braces (token, opening_brace)
    plume.error(token, "Syntax error : this brace doesn't matching the opening brace, which was '"..opening_brace.."'.")
end

function plume.syntax_error_lua_missing_end (token, opening)
    plume.error(token, "Syntax error : expecting 'end' to close '"..opening.."'.")
end


function plume.syntax_error_brace_unclosed (token)
    plume.error(token, "Syntax error : this brace was never closed.")
end

function plume.syntax_error_cannot_use_inside_optionnal_block (token)
    plume.error(token, "Syntax error : cannot use '" .. token.kind .. "' in optionnal parameters declaration. Please place braces around, or use raw text.")
end

function plume.syntax_error_expected_parameter_value(token)
    plume.error(token, "Expected parameter value, not '" .. token.value .. "'.")
end

function plume.syntax_error_expected_parameter_name(token)
    plume.error(token, "Expected parameter name, not '" .. token.value .. "'.")
end

function plume.syntax_error_lua_eof (token)
    plume.error(token, "Cannot end a lua script with '" .. token.value .. "'.")
end

function plume.error_syntax_invalid_for_iterator (token)
    plume.error(token, "Non valid syntax for iterator.")
end
end
plume_files['plume-engine.messages.warnings'] = function ()


-- Function to make warning messages in specific cases

--- Issues a warning when a macro already exists with the same name
-- @param token table The token containing the macro name
-- @param macro table Reference to already existing macro
function plume.warning_macro_already_exists(token, macro)
    local scope = plume.get_scope(token.context)
    
    if scope:get("config", "show_macro_overwrite_warnings") ~= true then
        return
    end

    local msg = "The macro '" .. macro.name .. "' already exists"
    local first_definition = macro.token

    -- Check if there is existing definition information available.
    if first_definition then
        msg = msg
            .. " (defined in file '"
            .. first_definition.file
            .. "', line "
            .. first_definition.line .. ").\n"
    else
        msg = msg .. ". "
    end

    -- If the macro is a standard macro, add a cautionary note to the warning message.
    if plume.std_macros[macro.name] then
        msg = msg .. " It is a standard macro, erase it only if you know what you're doing. Consider using `\\local_macro " .. macro.name .. "`."
    end

    plume.warning(token, msg)
end

--- Generates a warning message for deprecated macros, indicating the version in which they will be removed and suggesting an alternative.
-- @param token string The token containing the macro name.
-- @param name string The name of the deprecated macro.
-- @param version string The version in which the macro will be removed.
-- @param alternative string The suggested alternative macro.
-- @return string A formatted warning message about the deprecated macro.
function plume.warning_deprecated_macro(token, name, version, alternative)
    local msg = "Macro '" .. name .. "' is deprecated, "
    msg = msg .. "and will be removed in version " .. version .. ". "
    msg = msg .. "Use '" .. alternative .. "' instead."
    
    return msg
end

--- Issues a warning when the global default value for evaluation is used.
-- This function warns users about potential errors when editing the eval default value due to its extensive use across Plume files.
-- @param token string The token associated with the evaluation context.
function plume.warning_using_global_default_on_eval(token)
    local msg = "Editing the eval default value globally can cause unexpected errors, as '$' is widely used across Plume files. Consider using \\local_default."
    
    plume.warning(token, msg)
end

end
plume_files['plume-engine.api'] = function ()


-- Manage methods that are visible from user
local api = {}

--- @api_variable Version of plume.
api._VERSION = plume._VERSION
--- @api_variable Hook to the internal `plume` table, for experimented users.
api.engine   = plume

--- @api_method Capture the local _lua_ variable and save it in the _plume_ local scope. This is automatically called by plume at the end of lua block in statement-mode.
-- @note Mainly for internal use, except in one case: when rendering a plume block declared inside Lua, because by default capture occurs only at the end of the chunk.
function api.capture_local()
    local index = 1
    local calling_token = plume.traceback[#plume.traceback]
    while true do
        local key, value = debug.getlocal(2, index)
        if key then
            local scope = plume.get_scope (calling_token.context)
            scope:set_local("variables", key, value)
        else
            break
        end
        index = index + 1 
    end
end

--- @api_method Searches for a file using the [plume search system](macros.md#include) and open it in the given mode. Return the opened file and the full path of the file.
-- @param path string The path where to search for the file.
-- @param open_mode="r" string Mode to open the file.
-- @param silent_fail=false boolean If true, the search will not raise an error if no file is found.
-- @return file The file found during the search, opened in the given mode.
-- @return founded_path The path of the file founded.
function api.open (path, open_mode, silent_fail)
    return plume.open (nil, {"?"}, path, open_mode, silent_fail)
end

--- @api_method Get a variable value by name in the current scope.
-- @param key string The variable name.
-- @return value The required variable.
-- @note `plume.get` may return a tokenlist, so may have to call `plume.get (name):render ()` or `plume.get (name):render_lua ()`. See [get_render](#get_render) and [get_render_lua](#get_render_lua).
function api.get (key)
    local scope = plume.get_scope()
    return scope:get("variables", key)
end

--- @api_method Get a variable value by name in the current scope. If the variable has a render method (see [render](#render)), call it and return the result. Otherwise, return the variable.
-- @param key string The variable name
-- @alias getr
-- @return value The required variable.
function api.get_render (key)
    local scope = plume.get_scope()
    local result = scope:get("variables", key)
    if type(result) == table and result.render then
        return result:render ()
    else
        return result
    end
end
api.getr = api.get_render

--- @api_method Get a variable value by name in the current scope. If the variable has a render_lua method (see [render_lua](#render_lua)), call it and return the result. Otherwise, return the variable.
-- @param key string The variable name
-- @alias lget
-- @return value The required variable.
function api.lua_get (key)
    local scope = plume.get_scope()
    local result = scope:get("variables", key)
    if type(result) == table and result.render_lua then
        return result:render_lua ()
    else
        return result
    end
end
api.lget = api.lua_get

--- @api_method Works like Lua's require, but uses Plume's file search system.
-- @param path string Path of the lua file to load
-- @return lib The require lib
function api.require (path)
    local file, filepath, error_message = plume.open (nil, {"?.lua", "?/init.lua"}, path, "r", true)
    if file then
        file:close ()
        filepath = filepath:gsub('%.lua$', '')
        return require(filepath)
    else
        error(error_message, 2)
    end
end

--- @api_method Create a macro from a lua function.
-- @param name string Name of the macro
-- @param arg_number Number of paramters to capture
-- @param f function
-- @param is_local bool Is the new macro local?
function api.export(name, params_number, f, is_local)
    local macro_params = {}
    for i=1, params_number do
        table.insert(macro_params, "x"..i)
    end
    plume.register_macro(name, macro_params, {}, function (params)
        local rparams = {}
        for i=1, params_number do
            rparams[i] = params.positionnals['x' .. i]:render()
        end
        return f(plume.unpack(rparams))
    end, nil, is_local)
end

--- @api_method Create a local macro from a lua function.
-- @param name string Name of the macro
-- @param arg_number Number of paramters to capture
-- @param f function
-- @param is_local bool Is the new macro local?
function api.export_local(name, params_number, f)
    api.export(name, params_number, f, true)
end

--- @api_method Check if we are inside a given macro
-- @param name string the name of the macro
-- @return bool True if we are inside a macro with the given name, false otherwise.
function api.is_called_by (name)
    for i = #plume.traceback, 1, -1 do
        if name == plume.traceback[i].value
            or plume.syntax.escape .. name == plume.traceback[i].value
        then
            return true
        end
    end
    return false
end

function api.warnings_all ()
    local scope = plume.get_scope()
    for warning in (
        [[show_deprecation_warnings 
        show_macro_overwrite_warnings
        show_beginner_warning
        ]]):gmatch('%S+') do
        scope:set("config", warning, true)
    end
end

--- Initializes the API methods visible to the user through `plume` variable.
function plume.init_api ()
    local plume_reference = {}

    local global_scope = plume.get_scope ()
    global_scope:set_local("variables", "plume", plume_reference)

    -- keep a reference to the user `plume` variable
    plume.running_api = plume_reference

    for k, v in pairs(api) do
        plume_reference[k] = v
    end

    --- User can edit configuration through a table
    plume_reference.config = setmetatable({}, {
        __newindex = function (self, k, v)
            global_scope:set ("config", k, v)
        end,

        __index = function (self, k)
            return global_scope:get("config", k)
        end
    })

    --- User can also edit configuration locally
    plume_reference.local_config = setmetatable({}, {
        __newindex = function (self, k, v)
            local scope = plume.get_scope()
            scope:set_local("config", k, v)
        end,

        __index = function (self, k)
            local scope = plume.get_scope()
            return scope:get("config", k)
        end
    })

    plume_reference.lconfig = plume_reference.local_config

    -- Used to pass temp variable
    plume_reference.temp = setmetatable({},
        {
            __index    = plume.temp,
            __newindex = function ()
                error ("Cannot write 'plume.temp'")
            end
        }
    )
end


end
plume_files['plume-engine.config'] = function ()


-- Configuration settings
plume.config = {}

-- Maximum number of nested macros. Intended to prevent infinite recursion errors such as `\macro foo {\foo}`.
plume.config.max_callstack_size = 100

-- Maximum of loop iteration for macro `\while` and `\for`.
plume.config.max_loop_size      = 1000

-- Deprecated. Will be removed in 1.0.
plume.config.ignore_spaces  = false

-- If set to false, no effect. If set to `x`, the `x` character will replace any group of spaces (except spaces beginning a line). See [spaces macros](macros.md#spaces) for more details about space control.
plume.config.filter_spaces = " "

-- If set to false, no effect. If set to `x`, the `x` character will replace any group of newlines. See [spaces macros](macros.md#spaces) for more details about space control.
plume.config.filter_newlines = "\n"

-- Show deprecation warnings created with [deprecate](macros.md#deprecate).
plume.config.show_deprecation_warnings  = false

-- Show warning occuring when overwriting already existing macro
plume.config.show_macro_overwrite_warnings = false

-- Show some warnings for unexperimented users
plume.config.show_beginner_warnings = false
end
plume_files['plume-engine.debug'] = function ()


-- Tools for debuging during Plume developpement

plume.debug = {}

local function norm(s, fill, l)
    fill = fill or " "
    l = l or 12
    s = s .. fill:rep(l - #s)
    return s
end

function plume.debug.print_tokens(tokens)
    for _, token in ipairs(tokens) do
        local value = token.value:gsub("\n", "\\n"):gsub("\r", "\\r"):gsub("%s", "_")
        print("->", norm(token.kind), norm(value))
    end
end

function plume.debug.print_parsed_tokens(tokens, indent)
    indent = indent or ""
    for _, token in ipairs(tokens) do
        local infos = norm(token.kind)
        if token.kind == "lua_statement"  then
            infos = infos .. "\t" .. token.opening_token.value
        elseif token.kind == "block_text" or token.kind == "space" or token.kind:match('^lua_.*') then
            infos = infos .. "\t'" .. token:source():gsub("\n", "\\n"):gsub("\r", "\\r"):gsub("%s", "_") .. "'"
        elseif token.kind == "macro"  then
            infos = infos .. "\t" .. token.value
        elseif token.kind == "code" then
        end

        print(indent .. "->", infos)

        if token.kind == "block" or token.kind == "opt_block"  or token.kind == "lua_statement" then
            plume.debug.print_parsed_tokens (token, indent .. "\t")
        elseif token.kind == "code" then
            plume.debug.print_parsed_tokens (token[2], indent .. "\t")
        end
    end
end


function plume.debug.tokenize (code)
    print("List of tokens :")
    print("", norm("Kind"), norm("Value"))
    local tokens = plume.tokenizer:tokenize(code, file)
    plume.debug.print_tokens(tokens)
end

function plume.debug.parse (code)
    local tokens = plume.tokenizer:tokenize(code, file)
    tokens = plume.parse(tokens)

    print("List of tokens after parsing:")
    print("", norm("Kind"), norm("Value"))
    plume.debug.print_parsed_tokens(tokens)
end
end
plume_files['plume-engine.error'] = function ()


-- Max number of character before cutting the line
local MAX_LINE_LENGTH = 80

--- Extracts information from a Lua error message.
-- @param message string The error message
-- @return table A table containing file, line number, line content, and position information
local function lua_info (lua_message)
    local file, noline, message = lua_message:match("^%s*%[(.-)%]:([0-9]+): (.*)")
    if not file then
        file, noline, message = lua_message:match("^%s*(.-):([0-9]+): (.*)")
    end
    if not file then
        return {
            file     = nil,
            noline   = "",
            line     = "",
            beginpos = 0,
            endpos   = -1
        }
    end

    noline = tonumber(noline)
    noline = noline - 1

    -- Get chunk id
    local chunk_id = tonumber(file:match('^string "%-%-chunk([0-9]-)%.%.%."'))
    
    local token = plume.lua_cache[chunk_id]
    if not token then
        plume.error(nil, "Internal error : " .. lua_message .. "\nPlease report it on Github : https://github.com/ErwanBarbedor/Plume_-_TextEngine")
    end

    -- If error occuring from extern file
    if token.lua_cache.filename then
        local line = plume.get_line (token.lua_cache.code, noline+1)

        return {
            file     = token.lua_cache.filename,
            noline   = noline-1,
            line     = line,
            beginpos = #line:match('^%s*'),
            endpos   = #line,
        }
    end

    local line = plume.get_line (token:source (), noline)

    return {
        file     = token:info().file,
        noline   = token:info().line + noline - 1,
        line     = line,
        beginpos = #line:match('^%s*'),
        endpos   = #line,
        token    = token
    }
end

--- Captures debug.traceback for error handling.
-- @param msg string The error message
-- @return string The error message
function plume.error_handler (msg)
    plume.lua_traceback = debug.traceback ()
    return msg
end

--- Enhances error messages by adding information about the token that caused it.
-- @param token table The token that caused the error (optional)
-- @param error_message string The raised error message
-- @param is_lua_error boolean Whether the error is due to lua script
-- @param show_traceback boolean Show, or not, the traceback
function plume.make_error_message (token, error_message, is_lua_error, show_traceback)
    
    -- Make the list of lines to prompt.
    local error_lines_infos = {}

    -- In case of lua error, get the precise line
    -- of the error, then add lua traceback.
    -- Edit the error message to remove
    -- file and line info.
    if is_lua_error then
        table.insert(error_lines_infos, lua_info (error_message))
        error_message = "(lua error) " .. error_message:gsub('^.-:[0-9]+: ', '')

        local traceback = (plume.lua_traceback or "")
        if show_traceback then
            local first_line = true
            for line in traceback:gmatch('[^\n]+') do
                if line:match('^%s*%[string "%-%-chunk[0-9]+%.%.%."%]') then
                    -- Remove first line, that already
                    -- be added.
                    if first_line then
                        first_line = false
                    else
                        local infos = lua_info (line)
                        table.insert(error_lines_infos, lua_info (line))
                        -- check if we arn't last line
                        if line:match('^%s*[string "%-%-chunk[0-9]+..."]:[0-9]+: in function <[string "--chunk[0-9]+..."]') then
                            break
                        end
                    end
                end
            end
        end
    end
    
    -- Add the token that caused
    -- the error.
    if token then
        table.insert(error_lines_infos, plume.token_info (token))
    end
    
    -- Then add all traceback, except "$" call and the token itself
    if show_traceback and plume.traceback then
        for i=#plume.traceback, 1, -1 do
            if (plume.traceback[i].kind ~= "eval")
            and not (token == plume.traceback[i] and i==1) then
                table.insert(error_lines_infos, plume.token_info (plume.traceback[i]))
            end
        end
    end

    -- Now, for each line print line info (file, noline, line content)
    -- For the first line, also print the error message.
    local error_lines = {}
    for i, infos in ipairs(error_lines_infos) do
        -- remove space in front of line
        local leading_space = infos.line:match('^%s*')
        local line          = infos.line:gsub('^%s*', '')
        local beginpos      = infos.beginpos - #leading_space
        local endpos        = infos.endpos - #leading_space

        local line_info
        if infos.file then
            line_info = "File '" .. infos.file .."', line " .. infos.noline .. " : "
        else
            line_info = ""
        end

        local indicator

        if #line > MAX_LINE_LENGTH then
            local cut_right = math.min(#line, math.max (endpos, MAX_LINE_LENGTH))
            local cut_left  = math.max(1, math.min (beginpos, #line - cut_right + 1))
            
            local lline = #line
            line = line:sub(cut_left, cut_right)
            if cut_right < lline then
                line = line .. "[...]"
            end
            if cut_left > 1 then
                line = "[...]" .. line
                beginpos = beginpos + 6
                endpos   = endpos   + 6
            end

            beginpos = beginpos - cut_left
            endpos   = endpos   - cut_left
        end

        if i==1 then
            line_info = line_info .. error_message .. "\n\t"
            indicator = (" "):rep(beginpos) .. ("^"):rep(endpos - beginpos)
        else
            line_info = "\t" .. line_info
            indicator = (" "):rep(#line_info + beginpos - 1) .. ("^"):rep(endpos - beginpos)
        end

        if i == 2 then
            table.insert(error_lines, "Traceback :")
        end

        table.insert(error_lines, line_info .. line .. "\n\t" .. indicator)
    end

    -- In some case, like stack overflow, we have 1000 times the same line
    -- So print up to two time the line, them count and print "same line X times"

    -- First search for duplicate lines
    local line_count = {}
    local last_line
    local count = 0
    for index, line in ipairs(error_lines) do
        if line == last_line then
            count = count + 1
        else
            if count > 2 then
                table.insert(line_count, {index, count})
            end
            count = 0
        end
        last_line = line
    end

    -- Then remove it and replace it by
    -- "(same line again X times)"
    local delta = 0
    for i=1, #line_count do
        local index = line_count[i][1]
        local count = line_count[i][2]

        for k=1, count-1 do
            table.remove(error_lines, index-count-delta)
        end
        table.insert(error_lines, index-count+1, "\t...\n\t(same line again "..(count-1).." times)")
        delta = delta + count
    end

    local error_message = table.concat(error_lines, "\n")
    
    return error_message
end
--- Create and throw an error message.
-- @param token table The token that caused the error (optional).
-- @param error_message string The error message to be raised.
-- @param is_lua_error boolean Indicates if the error is related to Lua script.
function plume.error (token, error_message, is_lua_error)
    -- If there is already an existing error, throw it.
    if plume.last_error then
        error(plume.last_error, -1)
    end

    -- Create a formatted error message.
    local error_message = plume.make_error_message (token, error_message, is_lua_error, true)

    -- Save the error message.
    plume.last_error = error_message

    -- Throw the error message.
    error(error_message, -1)
end

function plume.warning (token, warning_message)
    local info = plume.token_info (token)
    local signature = info.file .. "@" .. info.line .. "@" .. info.beginpos

    if not plume.warning_cache[signature] then
        plume.warning_cache[signature] = true
        print("Warning : " .. plume.make_error_message (token, warning_message))
    end
end
end
plume_files['plume-engine.init'] = function ()


-- Following Lua best practices, plume should be local.
-- But given the current organization of the code, this would require a major rewrite.
plume = {}
plume._VERSION = "Plume - TextEngine 0.12.0"

require "plume-engine.config"
require "plume-engine.syntax"
require "plume-engine.render"
require "plume-engine.token"
require "plume-engine.tokenize"
require "plume-engine.tokenize_plume"
require "plume-engine.tokenize_lua"
require "plume-engine.parse"
require "plume-engine.error"
require "plume-engine.macro"
require "plume-engine.runtime"
require "plume-engine.initialization"
require "plume-engine.api"
require "plume-engine.debug"

require "plume-engine.messages.errors"
require "plume-engine.messages.syntax_errors"
require "plume-engine.messages.warnings"

--- Tokenizes, parses, and renders a string.
-- @param code string The code to render
-- @param file string The name used to track the code
-- @return string The rendered output
function plume.render (code, file)
    local tokens, result
    
    tokens = plume.tokenizer:tokenize(code, file)
    tokens = plume.parse(tokens)
    result = tokens:render()
    
    return result
end

--- Reads the content of a file and renders it.
-- @param filename string The name of the file to render
-- @return string The rendered output
function plume.renderFile(filename)
    local file = io.open(filename, "r")
        assert(file, "File " .. filename .. " doesn't exist or cannot be read.")
        local content = file:read("*all")
    file:close()
    
    local result = plume.render(content, filename)

    return result
end

return plume
end
plume_files['plume-engine.initialization'] = function ()


-- Initialisation of Plume - TextEngine

plume._LUA_VERSION = _VERSION
-- Save all lua standard functions to be available from "eval" macros
local lua_std_functions

if _VERSION == "Lua 5.1" then
    if jit then
        plume._LUA_VERSION = "Lua jit"
        lua_std_functions = "_VERSION assert bit collectgarbage coroutine debug dofile error gcinfo getfenv getmetatable io ipairs jit load loadfile loadstring math module newproxy next os package pairs pcall print rawequal rawget rawset require select setfenv setmetatable string table tonumber tostring type unpack xpcall"
    else
        lua_std_functions = "_VERSION assert collectgarbage coroutine debug dofile error gcinfo getfenv getmetatable io ipairs load loadfile loadstring math module newproxy next os package pairs pcall print rawequal rawget rawset require select setfenv setmetatable string table tonumber tostring type unpack xpcall"
    end
elseif _VERSION == "Lua 5.2" then
    lua_std_functions = "_VERSION assert bit32 collectgarbage coroutine debug dofile error getmetatable io ipairs load loadfile loadstring math module next os package pairs pcall print rawequal rawget rawlen rawset require select setmetatable string table tonumber tostring type unpack xpcall"
elseif _VERSION == "Lua 5.3" then
    lua_std_functions = "_VERSION assert bit32 collectgarbage coroutine debug dofile error getmetatable io ipairs load loadfile math next os package pairs pcall print rawequal rawget rawlen rawset require select setmetatable string table tonumber tostring type utf8 xpcall"
elseif _VERSION == "Lua 5.4" then
    lua_std_functions = "_VERSION assert collectgarbage coroutine debug dofile error getmetatable io ipairs load loadfile math next os package pairs pcall print rawequal rawget rawlen rawset require select setmetatable string table tonumber tostring type utf8 warn xpcall"
end

plume.lua_std_functions = {}
for name in lua_std_functions:gmatch('%S+') do
    plume.lua_std_functions[name] = _G[name]
end

--- Resets or initializes all session-specific tables.
function plume.init ()
    -- A table that contain
    -- all local scopes.
    plume.scopes = {}

    -- Create the first local scope
    -- (indeed, the global one)
    local global_scope = plume.push_scope ()

    --- @scope_variable _G Globale table of variables.
    global_scope:set("variables", "_G", global_scope:bridge_to("variables"))

    -- Used to pass temp variable
    plume.temp = {}
    
    -- Init methods that are visible from user
    plume.init_api ()

    -- Cache lua code to not
    -- call "load" multiple times
    -- for the same chunk
    plume.lua_cache    = {}

    -- Track number of chunks,
    -- To assign a number of each
    -- of them.
    plume.chunk_count = 0

    -- Used to store call to plume.write
    plume.write_stack = {}
        
    -- Add all std function into
    -- global scope
    for k, v in pairs(plume.lua_std_functions) do
        global_scope:set("variables", k, v)
    end

    -- Initialise configuration
    for k, v in pairs(plume.config) do
        global_scope:set("config", k, v)
    end

    plume.load_macros()

    -- Deprecate
    -- plume.deprecate("name", "version removal", "alternative")

    -- Warning cache
    plume.warning_cache = {}

    -- Initialise error tracing
    plume.last_error = nil
    plume.traceback = {}
end
end
plume_files['plume-engine.macro'] = function ()


-- Implement macro behavior

--- Registers a new macro.
-- @param name string The name of the macro
-- @param params table The arguments names of the macro
-- @param default_opt_params table Default names and values for optional arguments
-- @param macro function The function to call when the macro is used
-- @param token token The token where the macro was declared. Used for debuging.
-- @param is_local bool Register globaly or localy? (optionnal - defaults false)
-- @param std bool It is a standard macro? (optionnal - defaults false)
-- @param variable_parameters_number bool Accept unknow parameters? (optionnal - defaults false)
function plume.register_macro (name, params, default_opt_params, macro, token, is_local, std, variable_parameters_number)
    local macro = {
        name                       = name,
        params                       = params,
        default_opt_params           = default_opt_params,
        user_opt_params              = {},
        macro                      = macro,
        token                      = token,
        variable_parameters_number = variable_parameters_number
    }

    local scope = plume.get_scope(token and token.context)

    if is_local then
        scope:set_local ("macros", name, macro)
    else
        scope:set ("macros", name, macro)
    end

    if std then
        plume.std_macros[name] = macro
    end

    -- Register keyword params
    for k, v in pairs(default_opt_params) do
        local keyword_name = tostring(macro) .. "@" .. k
        scope:set("default", keyword_name, v)
    end

    return macro
end

--- Render token or return the given value
-- @param x
-- Usefull for macro, that can have no-token default parameters.
function plume.render_if_token (x)
    if type(x) == "table" and x.render_lua then
        return x:render_lua( )
    end
    return x
end

function plume.load_macros()
    -- to save the name of predefined macros
    plume.std_macros = {}

    require "plume-engine.macros.controls" ()
    require "plume-engine.macros.macros" ()
    require "plume-engine.macros.utils" ()
    require "plume-engine.macros.files" ()
    require "plume-engine.macros.eval" ()
    require "plume-engine.macros.spaces" ()
end
end
plume_files['plume-engine.parse'] = function ()


--- Converts a flat list of tokens into a nested structure.
-- Handles blocks, optional blocks, and text grouping
-- @param tokenlist table The list of tokens to parse
-- @return tokenlist The parsed nested structure
function plume.parse (tokenlist)
    local stack = {plume.tokenlist("block")}

    for pos, token in ipairs(tokenlist) do
        local top = stack[#stack]

        if token.kind == "block_begin" then
            eval_var = 0
            table.insert(stack, plume.tokenlist("block"))
            stack[#stack].opening_token = token
        
        elseif token.kind == "block_end" then
            eval_var = 0
            local block = table.remove(stack)
            local top = stack[#stack]

            -- Check if match the oppening brace
            if not top then
                plume.syntax_error_brace_close_nothing (token)
            elseif block.kind ~= "block" then
                plume.syntax_error_wrong_block_end (token, block.opening_token.value)
            end
            
            block.closing_token = token

            local parent = stack[#stack]
            table.insert(parent, block)
        
        elseif token.kind == "opt_block_begin" then
            table.insert(stack, plume.tokenlist("opt_block"))
            stack[#stack].opening_token = token
        
        elseif token.kind == "opt_block_end" then
            local last = table.remove(stack)
            local top = stack[#stack]

            -- Check if match the oppening brace
            if not top then
                plume.syntax_error_brace_close_nothing (token)
            elseif last.kind ~= "opt_block" then
                plume.syntax_error_wrong_block_end (token, block.opening_token.value)
            end

            last.closing_token = token
            local parent = stack[#stack]
            
            -- Check if last token is an eval without optionnal block
            local previous = parent[#parent]
            if previous and previous.kind == "code" and #previous == 2 then
                parent = previous
            end

            table.insert(parent, last)

        elseif token.kind == "lua_statement" then
            table.insert(stack, plume.tokenlist(token.kind))
            stack[#stack].opening_token = token
        elseif token.kind == "lua_function" then
            local kind = "lua_function"
            -- Checks if it as named function or not
            local look_ahead = pos
            while look_ahead < #tokenlist do
                look_ahead = look_ahead + 1
                local token = tokenlist[look_ahead]
                if token.kind == "lua_word" then
                    kind = "lua_statement"
                    break
                elseif token.kind ~= "space" then
                    break
                end
            end
            table.insert(stack, plume.tokenlist(kind))
            stack[#stack].opening_token = token
        elseif token.kind == "lua_end" then
            local last = table.remove(stack)
            local top = stack[#stack]

            -- Check if match the oppening brace
            if not top then
                plume.syntax_error_brace_close_nothing (token)
            elseif last.opening_token.value ~= "if" and last.opening_token.value ~= "for" and last.opening_token.value ~= "do" and last.opening_token.value ~= "while" and last.opening_token.value ~= "elseif" and last.opening_token.value ~= "function" then
                plume.syntax_error_wrong_block_end (token, last.opening_token.value)
            end

            last.closing_token = token
            table.insert(top, last)

        elseif token.kind == "lua_call_begin" then
            table.insert(stack, plume.tokenlist("lua_call"))
            stack[#stack].opening_token = token
        elseif token.kind == "lua_call_end" then
            local block = table.remove(stack)
            block.closing_token = token
            local parent = stack[#stack]
            table.insert(parent, block)
        
        elseif token.kind == "lua_index_begin" then
            table.insert(stack, plume.tokenlist("lua_index"))
            stack[#stack].opening_token = token
        elseif token.kind == "lua_index_end" then
            local block = table.remove(stack)
            block.closing_token = token
            local parent = stack[#stack]
            table.insert(parent, block)

        elseif token.kind == "lua_table_begin" then
            table.insert(stack, plume.tokenlist("lua_table"))
            stack[#stack].opening_token = token
        elseif token.kind == "lua_table_end" then
            local block = table.remove(stack)
            block.closing_token = token
            local parent = stack[#stack]
            table.insert(parent, block)

        elseif token.kind == "text" 
            or token.kind == "escaped_text" 
            or token.kind == "opt_assign" and top.kind ~= "opt_block" then

            local last = stack[#stack]
            if #last == 0 or last[#last].kind ~= "block_text" then
                table.insert(last, plume.tokenlist("block_text"))
            end
            table.insert(last[#last], token)
        
        elseif token.kind == "eval" then
            table.insert(stack, plume.tokenlist("code"))
            table.insert(stack[#stack], token)
            
        else
            table.insert(stack[#stack], token)
        end

        -- If last block is code, close it after capture two tokens.
        local last = stack[#stack]
        if last.kind == "code" and #last == 2 then
            local code   = table.remove(stack)
            local parent =  stack[#stack]

            table.insert(parent, code)
        end
    end

    -- Check if all braces are closed
    if #stack > 1 then
        plume.syntax_error_brace_unclosed (stack[#stack].opening_token)
    end

    return stack[1] 
end
end
plume_files['plume-engine.render'] = function ()


--- Parses optional arguments when calling a macro, then add default value if any
-- @param macro table The macro being called
-- @param params table The arguments table to be filled
-- @param opt_params table The optional arguments to parse
-- @param context table Scope to search default parameters for
function plume.make_opt_params (macro, params, opt_params, context)
    local key, eq, space
    local flags = {}

    local function capture_keyword(key, value)
        local name = key:render ()
        
        if macro.default_opt_params[name] == nil then
            if macro.variable_parameters_number then
                params.others.keywords[name] = value
            else
                plume.error_unknown_parameter (key, macro.name, name, macro.default_opt_params)
            end
        else
            params.keywords[name] = value
        end
    end

    local function capture_flag (key)
        local name = key:render ()

        -- trim name
        name = name:gsub('^%s+', ''):gsub('%s+$', '')

        -- empty flag don't raise an error
        if #name == 0 then
            return
        end

        if macro.variable_parameters_number then
            table.insert(params.others.flags, name)
        elseif macro.default_opt_params[name] == nil then
            plume.error_unknown_parameter (key, macro.name, name, macro.default_opt_params)
        else
            flags[name] = true
            table.insert(params.flags, name)
        end
    end

    local i=0
    while i < #opt_params do
        i = i + 1
        token = opt_params[i]
        
        -- Anything that is not ${...}, "=", a block, a comment or a space (in fact, macros)
        -- will lead to an error
        if token.kind ~= "opt_assign" and token.kind ~= "comment"
            and token.kind ~= "block" and token.kind ~= "block_text"
            and token.kind  ~= "space" and token.kind  ~= "newline" and token.kind  ~= "code" then
            plume.syntax_error_cannot_use_inside_optionnal_block (token)
        end

        if key then
            if token.kind == "space" or token.kind == "newline" or token.kind == "comment" then
            elseif eq then
                if token.kind == "opt_assign" then
                    plume.syntax_error_expected_parameter_value(token)
                end
                
                capture_keyword (key, token)
                
                eq = false
                key = nil
            elseif token.kind == "opt_assign" then
                eq = true
            else
                capture_flag(key)
                key = token
            end
        elseif token.kind == "opt_assign" then
            plume.syntax_error_expected_parameter_name(token)
        elseif token.kind ~= "space" and token.kind ~= "newline" and token.kind ~= "comment" then
            key = token
        end
    end
    if key then
        capture_flag(key)
    end

    local scope = plume.get_scope (context)
    for k, _ in pairs(macro.default_opt_params) do
        if not params.keywords[k] then
            local keyword_name = tostring(macro) .. "@" .. k
            local v = scope:get("default", keyword_name)
            params.keywords[k] = v
        end
    end

    for k, v in pairs(scope.default[tostring(macro) .. "?keywords"] or {}) do
        if not params.others.keywords[k] then
            params.others.keywords[k] = v
        end
    end

    for _, k in pairs(scope.default[tostring(macro) .. "?flags"] or {}) do
        if not params.keywords[k] then
            table.insert(params.others.flags, k)
        end
    end
end

--- Captures macro arguments from a token list, ensuring correct syntax and handling optional blocks.
-- @param tokenlist table The list of tokens to parse.
-- @param macro_token table The macro token used as reference for error messages.
-- @param pos number The current position in the token list.
-- @param nargs number The number of arguments to capture.
-- @return number The new position in the token list after processing.
-- @return table The list of captured macro arguments.
-- @return table|nil The optional parameter, if any.
function plume.capture_macro_args(tokenlist, macro_token, pos, nargs)
    local params = {}
    local opt_params

    -- if it is an eval token, parameter is saved inside
    if macro_token.kind == "code" then
        table.insert(params, macro_token[2])
        opt_params = macro_token[3]
    end

    -- Iterate over token list child until getting enough parameters
    while #params < nargs do
        pos = pos + 1

        -- End reached, but not enough arguments
        if not tokenlist[pos] then
            plume.error_end_block_reached(macro_token, #params, nargs)
        
        -- Macro as a parameter must be enclosed in braces, to avoid
        -- nested parameters capture
        elseif tokenlist[pos].kind == "macro" then
            plume.error_macro_call_without_braces (macro_token, tokenlist[pos], #params + 1)
       
        -- Lua block is the only exception, because it's parameter is already
        -- captured in the parser.
        elseif tokenlist[pos].kind == "code" then
            table.insert(params, tokenlist[pos])
        
        -- Register an optional argument, or raise an error if too many.
        elseif tokenlist[pos].kind == "opt_block" then
            
            if opt_params then
                plume.error(tokenlist[pos], "Too many optional blocks given for macro '" .. macro_token.value .. "'")
            else
                opt_params = tokenlist[pos]
            end
            
        -- If it is not a space or newline, add the current block
        -- to the argument list
        elseif tokenlist[pos].kind ~= "space" and tokenlist[pos].kind ~= "newline" then
            table.insert(params, tokenlist[pos])
        end
    end

    -- Try to capture the optional block after the last parameters
    -- Useful for macros without required parameters, but with optional ones
    if not opt_params then
        local test_pos = pos
        while tokenlist[test_pos+1] do
            test_pos = test_pos+1
            if tokenlist[test_pos].kind == "opt_block" then
                opt_params = tokenlist[test_pos]
                pos = test_pos
                break

            -- stop searching if hint anything that isn't a space
            elseif tokenlist[test_pos].kind ~= "space" and tokenlist[test_pos].kind ~= "newline" then
                break
            end
        end
    end

    return pos, params, opt_params
end

function plume.call_macro (macro, calling_token, parameters, chain_sender, chain_message)
        
    local traceback_token = calling_token
    if calling_token.kind == "code" then
        traceback_token = calling_token[1]
    end

    -- Update traceback
    table.insert(plume.traceback, traceback_token)
        -- call the macro
        local success, macro_call_result = pcall(function ()
            return { macro.macro (
                parameters,
                calling_token, -- send self token to throw error, if any
                chain_sender,
                chain_message
            ) }
        end)

        local call_result
        if success then
            call_result, chain_message = macro_call_result[1], macro_call_result[2]
        else
            plume.error(calling_token, "Unexpected lua error running the macro : " .. macro_call_result)
        end

        -- code is a tokenlist, not a token
        if calling_token.kind ~= "code" then
            chain_sender = calling_token.value
        end
    -- end of call
    table.remove(plume.traceback)

    return call_result, chain_sender, chain_message
end

--- @api_method Get tokenlist rendered.
-- @name render
-- @return output The string rendered tokenlist.
function plume.render_token (self)
    local pos = 0
    local result = {}

    -- dirty fix
    if self.kind == "code" then
        local container = plume.tokenlist ("block")
        table.insert(container, self)
        return container:render()
    end

    -- Chain of information passed to adjacent macros
    -- Used to achieve \if \else behavior
    local chain_sender, chain_message

    -- Used to skip space at line beginning
    -- local last_is_newline = false

    local scope = plume.get_scope (self.context)

    -- Iterate over token childs
    while pos < #self do
        pos = pos + 1
        local token = self[pos]

        -- Get current configuration
        -- update after each child because any token can change it
        local config_filter_newlines    = scope:get("config", "filter_newlines")
        local config_filter_spaces      = scope:get("config", "filter_spaces")
        local config_max_callstack_size = scope:get("config", "max_callstack_size")

        -- Break the chain if encounter non macro non space token
        if token.kind ~= "newline" and token.kind ~= "space" and token.kind ~= "macro" and token.kind ~= "comment" then
            chain_sender  = nil
            chain_message = nil
        end

        if token.kind ~= "space" and token.kind ~= "newline" then
            -- print(token.kind)
            plume.last_is_newline = false
        end

        -- Call recursively render method on block
        if token.kind == "block_text" or token.kind == "block" then
            table.insert(result, token:render())

        -- No special render for text
        elseif token.kind == "text" or token.kind == "escaped_text" then
            table.insert(result, token.value)

        -- If optionnal blocks or assign are encoutered here, there
        -- are outside of a macro call, so treat it as normal text
        elseif token.kind == "opt_block" then
            table.insert(result,
                plume.syntax.opt_block_begin
                .. token:render() 
                .. plume.syntax.opt_block_end
            )
        elseif token.kind == "opt_assign" then
            table.insert(result, token.value)

        -- For space and newline, apply filter if exist.
        elseif token.kind == "newline" then
            if config_filter_newlines then
                if not plume.last_is_newline then
                    table.insert(result, config_filter_newlines)
                    plume.last_is_newline = true
                end
            elseif token.__type == "token" then
                table.insert(result, token.value)
            else
                table.insert(result, token:render())
            end
        elseif token.kind == "space" then
            if config_filter_spaces then
                if plume.last_is_newline then
                    plume.last_is_newline = false
                else
                    table.insert(result, config_filter_spaces)
                end
            else
                table.insert(result, token.value)
            end

        -- Capture required number of parameters after the macro, then call it
        elseif token.kind == "macro" or token.kind == "code" then
            -- If more than config_max_callstack_size macro are running, throw an error.
            -- Mainly to adress "\macro foo \foo" kind of infinite loop.
            local up_limit = config_max_callstack_size
            
            if #plume.traceback > up_limit then
                plume.error(token, "To many intricate macro call (over the configurated limit of " .. up_limit .. ").")
            end

            -- Remove the "\" in front of macro to get the name
            local name

            -- "$" is a syntax sugar for "eval"
            if token.kind == "code" then
                name = "eval"
            else
                name = token.value:gsub("^"..plume.syntax.escape , "")
            end

            -- Check if the given name is a valid identifier
            if not plume.is_identifier(name) then
                plume.error_invalid_macro_name (token, name, "macro")
            end
            

            -- Check if macro exist
            local macro = scope:get("macros", name)
            if not macro then
                plume.error_macro_not_found(token, name)
            end

            -- Capture parameters
            local params, opt_params
            pos, params, opt_params = plume.capture_macro_args (self, token, pos, #macro.params)

            -- Rearange parameters for the call
            local macro_params = {
                positionnals={}, -- positionnal parameters
                keywords={},     -- optionnal parameters
                flags={},        -- syntax suger for some optionnal parameters
                others={         -- "others" is used if a macro accepts a variable number of parameters.
                    keywords={},
                    flags={}
                }
            }


            -- All captured parameters are postionnals
            for k, v in ipairs(params) do
                macro_params.positionnals[macro.params[k]] = v
            end

            -- Parse and add optionnals one. Add default values if any
            plume.make_opt_params(macro, macro_params, opt_params or {}, token.context)

            -- call macro
            local macro_call_result
            macro_call_result, chain_sender, chain_message = plume.call_macro (
                macro,
                token,
                macro_params,
                chain_sender,
                chain_message
            )

            -- Add result to the output
            table.insert(result, tostring(macro_call_result or ""))
        end
        
    end
    return table.concat(result)
end

--- @api_method Get tokenlist rendered. If the tokenlist first child is an eval block, evaluate it and return the result as a lua object. Otherwise, render the tokenlist.
-- @name render_lua
-- @return lua_objet Result of evaluation
function plume.render_token_lua (self)
    if self.kind == "code" then
        local result = plume.call_lua_chunk(self[2])
        if type(result) == "table" and result.__type == "tokenlist" then
            result = result:render ()
        end
        return result
    else
        local result = self:render ()
        return tonumber(result) or result
    end
end
end
plume_files['plume-engine.runtime'] = function ()


-- Manage scopes and runtime lua executions

if _VERSION == "Lua 5.1" then
    plume.load_lua_chunk  = loadstring
    plume.setfenv = setfenv
    plume.unpack  = unpack
elseif _VERSION == "Lua 5.2" or _VERSION == "Lua 5.3" or _VERSION == "Lua 5.4" then
    plume.load_lua_chunk = load
    plume.unpack  = table.unpack
    --- Sets the environment of a given function.
    -- Uses the debug library to achieve setfenv functionality
    -- by modifying the _ENV upvalue of the function.
    -- @param func function The function whose environment is to be set.
    -- @param env table The new environment table to be set for the function.
    -- @return The function with the modified environment.
    function plume.setfenv(func, env)
        -- Initialize the upvalue index to 1
        local i = 1

        -- Iterate through the upvalues of the function
        while true do
            -- Retrieve the name of the upvalue at index i
            local name = debug.getupvalue(func, i)

            -- Check if the current upvalue is _ENV
            if name == "_ENV" then
                -- Use debug.upvaluejoin to set the new environment for _ENV
                debug.upvaluejoin(func, i, (function() return env end), 1)
                break
            -- If there are no more upvalues to check, break the loop
            elseif not name then
                break
            end

            -- Increment the upvalue index
            i = i + 1
        end

        -- Return the function with the updated environment
        return func
    end
end

--- Loads, caches, and executes Lua code.
-- @param token table The token containing the code
-- or, if code is given, token used to throw error
-- @param code string The Lua code to execute (optional)
-- @param filename string If is extern lua code, name of the source file (optionnal)
-- @return any The result of the execution
function plume.call_lua_chunk(token, code, filename)
    -- Used to store references to inserted plume blocks
    local temp = {}
    code = code or token:source_lua (temp)

    if not token.lua_cache then
        -- Edit the code to add a "return", in case of an expression,
        -- or plume.capture_local() at the end in case of statement.
        -- Also put the chunk number in the code, to retrieve it in case of error.
        -- A bit messy, but each chunk executes in its own environment, even if they
        -- share the same code. A more elegant solution certainly exists,
        -- but this does the trick for now.
        plume.chunk_count = plume.chunk_count + 1
        code = "--chunk" .. plume.chunk_count .. '\n' .. code
        
        local loaded_function, load_err = plume.load_lua_chunk(code)

        -- In case of syntax error
        if not loaded_function then
            -- save it in the cache anyway, so
            -- that the error handler can find it 
            token.lua_cache = {code=code, filename=filename}
            table.insert(plume.lua_cache, token)
            plume.error(token, load_err, true)
        end

        local chunck = setmetatable({
            code              = code,
            filename          = filename,
            is_lua_expression = lua_expression
        },{
            __call = function ()
                -- The function can write and read variable of the current scope
                local scope = plume.get_scope(token.context)
                plume.setfenv (loaded_function, scope:bridge_to("variables"))

                for k, v in pairs(temp) do
                    plume.temp[k] = v
                end

                local result = { xpcall (loaded_function, plume.error_handler) }

                -- Dont remove plume variable for now. May be a memory leak, 
                -- but however function return ${foo} end could not work.
                -- for k, v in pairs(temp) do
                --     plume.temp[k] = nil
                -- end

                return result
            end
        })

        token.lua_cache = chunck
        -- Track the code for debug purpose
        table.insert(plume.lua_cache, token)
    end

    table.insert(plume.write_stack, {})
    local result = token.lua_cache ()

    local sucess = result[1]
    table.remove(result, 1)

    if not sucess then
        plume.error(token, result[1], true)
    end

    return (unpack or table.unpack)(result)
end

--- Creates a scope field
-- @param scope table The scope where the field is created.
-- @param field_name string The name of the field to create.
-- @param parent table The parent table for inheritance.
-- @param source table The source table for raw field access.
local function make_field(scope, field_name, parent, source)
    scope[field_name] = setmetatable({}, {
        __index = function (self, key)
            -- Return the registered value.
            -- If the value is nil, recursively call the parent.
            local value
            if source then
                value = rawget(source[field_name], key)
            else
                value = rawget(self, key)
            end

            if value then
                return value
            elseif parent then
                return parent[field_name][key]
            end
        end,
        __newindex = function (self, key, value)
            -- Register a new value.
            -- If there is a parent and the key does not exist in the source,
            -- send the value to the parent. Otherwise, register it.
            if parent  then
                parent[field_name][key] = value
            else
                rawset(self, key, value)
            end
        end,
    })
end


--- Creates a new scope with the given parent.
-- @param parent scope The parent scope
-- @return table The new scope
function plume.create_scope (parent)
    local scope = {}

    -- Store all variables values, accessibles from user
    make_field (scope, "variables", parent)
    -- Store references to declared local variables in the current scope,
    -- but with a nil value
    make_field (scope, "nil_local", parent)
    -- Store macro
    make_field (scope, "macros",    parent)
    -- Store default parameters for macro
    make_field (scope, "default",   parent)
    -- Store configuration
    make_field (scope, "config",    parent)

    --- Returns all variables of the given field that are visible from this scope.
    -- @param self table The current scope.
    -- @param field string The field from which to retrieve variables.
    -- @return table A table containing all variables from the given field.
    function scope.get_all(self, field)
        local t = {}
        
        if source then
            for _, k in ipairs(source:get_all(field)) do
                table.insert(t, k)
            end
        else
            for k, _ in pairs(self[field]) do
                table.insert(t, k)
            end
        end

        -- If a parent scope exists, recursively get variables from the parent's field
        if parent then
            for  _, k in ipairs(parent:get_all(field)) do
                table.insert(t, k)
            end
        end

        return t
    end

    --- Registers a variable locally in the given scope
    -- @param key string The key to set
    -- @param value any The value to set
    function scope.set_local(self, field, key, value)
        
        if value then
            rawset (scope[field], key, value)
        else
            -- If the value is nil, keep a reference
            -- '@' is to make the name unique
            rawset (scope["nil_local"], field .. "@" .. key, true)
        end
    end

    --- Registers a variable globaly
    -- @param key string The key to set
    -- @param value any The value to set
    function scope.set(self, field, key, value)
        -- If no parent or if the variable is already registered
        -- save it in this scope
        -- Otherwise send the value to the parent
        if not parent or rawget(scope[field], key) ~= nil  then
            rawset (scope[field], key, value)
        else
            parent:set (field, key, value)
        end
    end

    --- Get the value of a given variable. Return local value if it exists, else search recursively in parents
    -- @param key string The key to set
    -- @param value any The value to set
    function scope.get(self, field, key)
        -- If the value is nil, recursively call the parent.
        local value = rawget(scope[field], key)

        if value ~= nil or rawget(scope.nil_local, field.."@"..key) then
            return value
        elseif parent then
            return parent:get(field, key)
        end
    end

    --- Creates a bridge object to interact with a specific scope field as table
    -- @param field string The name of the field in the scope to bridge to
    function scope.bridge_to(self, field)
        return setmetatable({}, {
            __newindex = function(self, key, value)
                scope:set(field, key, value)
            end,

            __index = function(self, key)
                return scope:get(field, key)
            end
        })
    end

    return scope
end

--- Creates a new scope with the penultimate scope as parent.
function plume.push_scope (scope)
    local last_scope = plume.get_scope ()
    local new_scope = plume.create_scope (scope or last_scope)

    table.insert(plume.scopes, new_scope)

    return new_scope
end

--- Removes the last created scope.
function plume.pop_scope ()
    table.remove(plume.scopes)
end

--- Returns the current scope or, if not nil, the scope given as a parameter.
-- @param scope table Return this scope if not nil
-- @return table The current scope
function plume.get_scope (scope)
    return scope or plume.scopes[#plume.scopes]
end


end
plume_files['plume-engine.syntax'] = function ()


plume.syntax = {
    -- identifier must be a lua valid identifier
    identifier           = "[a-zA-Z0-9_]",
    identifier_begin     = "[a-zA-Z_]",

    -- all folowing must be one char long
    escape               = "\\",
    comment              = "-",-- comments are two plume.syntax.comment char next to each other.
    block_begin          = "{",
    block_end            = "}",
    opt_block_begin      = "[",
    opt_block_end        = "]",
    opt_assign           = "=",
    eval                 = "$"
}

plume.lua_syntax = {
    identifier       = plume.syntax.identifier,
    identifier_begin = plume.syntax.identifier_begin,
    simple_quote     = "'",
    double_quote     = '"',
    escape           = "\\",
    comment          = "-",

    call_begin       = "(",
    call_end         = ")",
    index_begin      = "[",
    index_end        = "]",
    table_begin      = "{",
    table_end        = "}",

    statement        = " for if while repeat do ",
    keyword          = " not and or in ",
    statement_alone  = " local ",
    function_keyword = "function",
    end_keyword      = "end",
    return_keyword   = "return"
}

--- Checks if a string is a valid identifier.
-- @param s string The string to check
-- @return boolean True if the string is a valid identifier, false otherwise
function plume.is_identifier(s)
    return s:match('^' .. plume.syntax.identifier_begin .. plume.syntax.identifier..'*$')
end
end
plume_files['plume-engine.token'] = function ()


--- Creates a new token.
-- Token represents a small chunk of code:
-- a macro, a newline, a word...
-- Each token tracks its position in the source code
-- @param kind string The kind of token (text, escape, ...)
-- @param value string Information about token behavior, may be different from code
-- @param line number The line number where the token appears
-- @param pos number The position in the line where the token starts
-- @param file string The file where the token appears
-- @param code string The full source code
-- @return token A new token object
function plume.token (kind, value, line, pos, file, code)
    return setmetatable({
        __type = "token",-- used mainly for debugging
        kind   = kind,
        value  = value,
        line   = line,
        pos    = pos,
        file   = file,
        code   = code,

        --- Returns the source code of the token
        -- @return string The source code
        source = function (self)
            return self.value
        end,

         --- Returns the source code of the token
        -- @return string The source code
        source_lua = function (self)
            return self.value
        end,
    }, {})
end

--- Convert one element into number
-- @param x tokenlist|number|string Element to convert
-- @return number The converted numbers
local function tokens2number(x)
    local nx, rx
    if type(x) == "table" and x.render then
        rx  = x:render()
        nx = tonumber(rx)
    else
        nx = tonumber (x)
    end

    if not nx then
        if type(x) == "table" and x.__type == "tokenlist" then
            plume.internal_error ("Cannot convert a token rendered as '".. rx .."' into number.")
        else
            error ("Cannot convert '" .. x .. "' (" .. type(x) .. ") into number.")
        end
    end

    return nx
end

--- Convert one element into string
-- @param x tokenlist|number|string Element to convert
-- @return number The converted numbers
local function tokens2string(x, y)
    
    if type(x) == "table" and x.render then
        x = x:render()
    else
        x = tostring(x)
    end

    return x
end

-- Categorize metamethods , for convenience :
-- Arguments of macros are passed as tokenlist without rendering it.
-- But \macro add[x y] ${tonumber(x:render()) + tonumber(y:render())} is quite cumbersome.
-- With metamethods, it becomes \macro add[x y] ${x+y}, with an implicit call to tokenlist:render ()
local metamethods_binary_numeric = {
    add  = function (x, y) return x+y end,
    sub  = function (x, y) return x-y end,
    div  = function (x, y) return x/y end,
    mul  = function (x, y) return x*y end,
    mod  = function (x, y) return x%y end,
    pow  = function (x, y) return x^y end,
    lt   = function (x, y) return x<y end,
    le   = function (x, y) return x<=y end
}

local metamethods_unary_numeric = {
    unm = function (x) return -x end
}

local metamethods_binary_string = {
    concat = function (x, y) return x..y end,
}

local metamethods_unary_string = {
    tostring = function (x) return x end,
}

-- Use load to avoid syntax error in prior versions of Lua.
if _VERSION == "Lua 5.3" or _VERSION == "Lua 5.4" then
    metamethods_binary_numeric.idiv = load("return function (x, y) return x//y end")()
    metamethods_binary_numeric.band = load("return function (x, y) return x&y end")()
    metamethods_binary_numeric.bor  = load("return function (x, y) return x|y end")()
    metamethods_binary_numeric.bxor = load("return function (x, y) return x~y end")()
    metamethods_binary_numeric.shl  = load("return function (x, y) return x>>y end")()
    metamethods_binary_numeric.shr  = load("return function (x, y) return x<<y end")()

    metamethods_unary_numeric.bnot = load("return function (x) return ~x end")()
end

--- Creates a new tokenlist.
-- @param x string|table Either a kind string or a table of tokens
-- @return tokenlist A new tokenlist object
function plume.tokenlist (x)
    local kind = "block"
    local t = {}

    if type(x) == "table" then
        t = x
    elseif x then
        kind = x
    end

    local metatable = {}

    for name, method in pairs(metamethods_binary_numeric) do
        metatable["__" .. name] = function (x, y)
            return method (tokens2number(x), tokens2number(y))
        end
    end

    for name, method in pairs(metamethods_unary_numeric) do
        metatable["__" .. name] = function (x)
            return method (tokens2number(x))
        end
    end

    for name, method in pairs(metamethods_binary_string) do
        metatable["__" .. name] = function (x, y)
            return method (tokens2string(x), tokens2string(y))
        end
    end

    for name, method in pairs(metamethods_unary_numeric) do
        metatable["__" .. name] = function (x)
            return method (tokens2string(x))
        end
    end

    function metatable.__index (self, key)
        if tonumber (key) then
            return rawget(self, key)
        end

        local result = rawget(self, key)
        if result then
            return result
        end

        -- Implicit rendering if key is a string method
        if not string[key] then
            return
        end

        local rendered = tostring(self:render_lua ())
        -- Handle both token:method and token.method call.
        return function (caller, ...)
            if caller == self then
                return string[key] (rendered, ...)
            else
                return string[key] (caller, ...)
            end
        end

    end

    local tokenlist = setmetatable({
        __type    = "tokenlist", --- Type of the table. Value : `"tokenlist"`
        kind      = kind,        --- Kind of tokenlist. Can be : `"block"`, `"opt_block"`, `"block_text"`, `"render-block"`.

        context   = nil,       --- The scope of the tokenlist. If set to false (default), search vars in the current scope.
        lua_cache = nil,       --- For eval tokens, cached loaded lua code.
        opening_token = nil, --- If the tokenlist is a "block" or an "opt_block",keep a reference to the opening brace, to track token list position in the code.
        closing_token = nil, --- If the tokenlist is a "block" or an "opt_block",keep a reference to the closing brace, to track token list position in the code.
        
        --- @intern_method Return debug informations about the tokenlist.
        -- @return debug_info A table containing fields : `file`, `line` (the first line of this code chunck), `lastline`, `pos` (first position of the code in the first line), `endpos`, `code` (The full code of the file).
        info = function (self)
            local first = self.opening_token or self[1]
            local last = self.closing_token or self[#self]

            if first.__type == "tokenlist" then
                first = first:info()
            end
            if last.__type == "tokenlist" then
                last = last:info()
            end

            return {
                file = first.file,
                line = first.line,
                lastline = last.line,
                code = first.code,
                pos  = first.pos,
                endpos = last.pos
            }
        end,

        --- @itern_method Copy the tokenlist.
        -- @return tokenlist The copied tokenlist.
        copy = function (self)
            local token_copy     = plume.tokenlist ()
            token_copy.kind      = self.kind
            token_copy.context   = self.context

            -- Hard fix, need a cleanup on token.first / token.last
            -- Uncomment break test "eval/Not to many eval"
            token_copy.opening_token = self.opening_token
            token_copy.closing_token = self.closing_token
            token_copy.lua_cache     = self.lua_cache

            for _, token in ipairs(self) do
                if token.__type == "tokenlist" then
                    table.insert(token_copy, token:copy())
                else
                    table.insert(token_copy, token)
                end
            end

            return token_copy

        end,

        --- @intern_method Freezes the scope for all tokens in the list.
        -- @param scope table The scope to freeze.
        -- @param forced boolean Force to re-freeze already frozen children?
        set_context = function (self, scope, forced)
            -- Each token keeps a reference to given scope
            for _, token in ipairs(self) do
                if token.__type == "tokenlist" then
                    token:set_context (scope, forced)
                end
                if forced then
                    token.context = scope
                else
                    token.context = token.context or scope
                end
            end
        end,
    
        --- @api_method Returns the raw code of the tokenlist, as is writed in the source file.
        -- @return string The source code
        source = function (self)

            local result = {}
            for _, token in ipairs(self) do
                if token.opening_token then
                    table.insert(result, token.opening_token:source ())
                end

                table.insert(result, token:source())
                
                if token.closing_token then
                    table.insert(result, token.closing_token:source ())
                end
            end
            
            return table.concat(result, "")
        end,

        --- @api_method Get lua code as writed in the code file, after deleting comment and insert plume blocks.
        -- @return string The source code
        source_lua = function (self, temp, can_return, can_alter_return)
            if can_return == nil then can_return = true end
            if can_alter_return == nil then can_alter_return = true end

            local result = {}
            local i = 0
            local is_expression = true
            local found_return  = false
            local last_kind = nil

            while i < #self do
                i = i+1
                local token = self[i]

                if last_kind and token.kind == "lua_word" and last_kind == "lua_word" then
                    is_expression = false
                elseif (last_kind == "lua_function" or last_kind == "lua_call") and (token.kind == "lua_word" or token.kind == "lua_function") then
                    is_expression = false
                end

                if token.kind ~= "space" and token.kind ~= "newline" then
                    last_kind = token.kind
                end
                
                if token.kind == "lua_statement" then
                    table.insert(result, token.opening_token.value)
                    is_expression = false
                elseif token.kind == "lua_function" then
                    table.insert(result, token.opening_token.value)
                elseif token.kind == "lua_code" and token.value == "=" then
                    is_expression = false
                elseif token.kind == "lua_statement_alone" then
                    is_expression = false
                elseif token.kind == "lua_call" then
                    table.insert(result, plume.lua_syntax.call_begin)
                elseif token.kind == "lua_index" then
                    table.insert(result, plume.lua_syntax.index_begin)
                elseif token.kind == "lua_table" then
                    table.insert(result, plume.lua_syntax.table_begin)
                end

                if token.kind == "comment" then

                -- It is a plume block inside lua code.
                -- Insert a reference to the parsed tokenlist.
                elseif token.kind == "code" then
                    local index = math.random (1, 100000)
                    while temp['token' .. index] do index = index + 1 end

                    local text = token[2]
                    temp['token' .. index] = text
                    table.insert(result, "plume.temp.token" .. index)
                    
                    -- Add line jump in code, to keep same numbering as source code
                    for _ in text:source():gmatch('\n') do
                        table.insert(result, '\n')
                    end
                elseif token.kind == "lua_return" then
                    is_expression = false
                    if can_alter_return then
                        table.insert(result, " plume.capture_local () return ")
                    else
                        table.insert(result, " return ")
                    end
                    found_return  = true
                elseif token.kind == "lua_function" or token.kind == "lua_call" or token.kind == "lua_index" or token.kind == "lua_table" then
                    table.insert(result, token:source_lua(temp, false, false))
                else
                    table.insert(result, token:source_lua(temp, false, true))
                end

                if token.kind == "lua_statement" or token.kind == "lua_function" then
                    table.insert(result, token.closing_token.value)
                elseif token.kind == "lua_call" then
                    table.insert(result, plume.lua_syntax.call_end)
                elseif token.kind == "lua_index" then
                    table.insert(result, plume.lua_syntax.index_end)
                elseif token.kind == "lua_table" then
                    table.insert(result, plume.lua_syntax.table_end)
                end
            end

            if can_return then
                if is_expression then
                    table.insert(result, 1, "return ")
                elseif not found_return then
                    table.insert(result, "\nplume.capture_local ()")
                end
            end

            return table.concat(result, "")
        end,

        --- @api_method Render the tokenlist and return true if it is empty
        -- @return bool Is the tokenlist empty?
        is_empty = function (self)
            return #self:render() == 0
        end,
        render    = plume.render_token,
        render_lua = plume.render_token_lua
    }, metatable)

    for k, v in ipairs(t) do
        tokenlist[k] = v
    end
    
    return tokenlist
end

--- Retrieves a line by its line number in the source code.
-- @param source string The source code
-- @param noline number The line number to retrieve
-- @return string The line at the specified line number
function plume.get_line(source, noline)
    local current_line = 1
    for line in (source.."\n"):gmatch("(.-)\n") do
        if noline == current_line then
            return line
        end
        current_line = current_line + 1
    end
end

--- Returns information about a token.
-- @param token table The token to get information about
-- @return table A table containing file, line number, line content,
-- and position information
function plume.token_info (token)

    local file, token_noline, token_line, code, beginpos, endpos

    -- code token is just a container
    if token.kind == "code" then
        token = token[2]
    end

    -- Find all informations about the token
    if token.kind == "opt_block" or token.kind == "block" then
        file = token:info().file
        token_noline = token:info().line
        code = token:info().code
        beginpos = token:info().pos

        if token:info().lastline == token_noline then
            endpos = token:info().endpos+1
        else
            endpos = beginpos+1
        end
    elseif token.kind == "block_text" then
        file = token:info().file
        token_noline = token:info().line
        code = token:info().code
        beginpos = token:info().pos

        endpos = token[#token].pos + #token[#token].value
    else
        file = token.file
        token_noline = token.line
        code = token.code
        beginpos = token.pos
        endpos = token.pos+#token.value
    end

    return {
        file     = file,
        noline   = token_noline,
        line     = plume.get_line (code, token_noline),
        beginpos = beginpos,
        endpos   = endpos
    }
end
end
plume_files['plume-engine.tokenize'] = function ()


plume.tokenizer = {}

--- Initializes the tokenizer with the given code and file.
-- @param code string The source code to be tokenized.
-- @param file string Optional. The filename from which the code originates. Defaults to "string".
function plume.tokenizer:init (code, file)
    self.code      = code
    self.tokenlist = plume.tokenlist("render-block") -- To store the final result of tokenization
    self.acc       = {} -- Accumulator to temporarily store characters before token creation

    self.mode      = nil -- Tracks the current type of token the tokenizer is processing
    self.context   = {"plume"} -- Last context define how to handle incomming char

    -- Track the current position in the code for error reporting and debugging
    self.noline    = 1 -- Current line number in the source code
    self.linepos   = 1 -- Position from the start of the current line
    self.pos       = 1 -- Position from the start of the entire code block
    self.file      = file or "string" -- The source filename; defaults to "string" if none provided
end

--- Get the plume code as raw string, and return a list of token.
-- @param code string The code to tokenize
-- @param file string The name of the file being tokenized, for debuging purpose. May be any string.
-- @return table A list of tokens
function plume.tokenizer:tokenize (code, file)
    -- Cannot tokenize nil code
    if code == nil then
        plume.error(nil, "Given code is nil.")
    end

    self:init (code, file)
    
    -- Iterate over each given code character
    while self.pos <= #self.code do
        local char = self.code:sub(self.pos, self.pos)

        local current_context = self.context[#self.context]

        if char == "\n" then
            self:write (nil, 0)
            self:newtoken ("newline", "\n", 1)
            self.noline = self.noline + 1
            self.linepos = self.pos+1
        
        elseif current_context == "plume" then
            self:handle_context_plume ()
        
        elseif current_context == "lua" then
            self:handle_context_lua ()

        elseif current_context == "lua_simple_quote" then
            self:handle_context_lua_string (plume.lua_syntax.simple_quote)

        elseif current_context == "lua_double_quote" then
            self:handle_context_lua_string (plume.lua_syntax.double_quote)
        end

        self.pos = self.pos + 1
    end
    
    -- Write any remaining char in the accumulator
    self:write ()

    return self.tokenlist
end

--- Creates a new token and inserts it into the result table.
-- @param kind string The type of the token.
-- @param value string The value or content of the token.
-- @param delta number An optional positional adjustment for the token.
function plume.tokenizer:newtoken(kind, value, delta)
    -- Calculate the position of the token by adjusting the current position with the length of the value,
    -- line position, and any additional delta provided.
    local position = self.pos - #value - self.linepos + (delta or 0)
    
    -- Create a new token using the provided details and insert it into the result table.
    table.insert(self.tokenlist, 
        plume.token(kind, value, self.noline, position, self.file, self.code)
    )
end

--- Create tokens from accumulated characters
-- @param current string The mode to write on
-- @param delta number The position offset for the new token.
function plume.tokenizer:write(current, delta)
    -- If the mode has changed, finalize the previous token and start a new token with updated mode.
    if not current or current ~= self.mode then
        -- If acc isn't empty, create a new token
        if #self.acc > 0 then
            local word = table.concat(self.acc, "")

            -- Checks for lua keywords
            mode = self.mode

            if mode == "lua_word" then
                mode = plume.tokenizer:lua_checks_keywords (mode, word)
            end

            self:newtoken(mode, word, delta)
        end

        -- Update the mode to the current mode and reset the accumulator.
        self.mode = current
        self.acc = {}
    end
end
end
plume_files['plume-engine.tokenize_lua'] = function ()


--- Handles lua syntax
-- This is far from a complete lua tokenizer. Used to implement 
-- syntax like ${a = "$foo", b = ${bar}}
-- with "$foo" detected as a simple string, and ${bar} detected
-- as a plume block.
-- Also used to determine if the code is an expression or a statement.
-- @param char string The syntax character to be handled
function plume.tokenizer:handle_context_lua ()
    local char = self.code:sub(self.pos, self.pos)

    -- Manage deepness with detecting opening and closing braces
    if char == plume.syntax.block_begin then
        table.insert(self.context, "lua")
    elseif char == plume.syntax.block_end then
        table.remove(self.context)
    end
    
    local current_context = self.context[#self.context]

    -- Check if the mode is always lua
    if current_context == "lua" then
        -- Check for plume comment
        if self:check_for_comment () or self:check_for_lua_comment () then
            self:handle_comment (true)

        -- Check for strings
        elseif char == plume.lua_syntax.simple_quote then
            self:write ("lua_block")
            table.insert(self.acc, char)
            table.insert(self.context, "lua_simple_quote")
        elseif char == plume.lua_syntax.double_quote then
            self:write ("lua_block")
            table.insert(self.acc, char)

            table.insert(self.context, "lua_double_quote")
        
        -- Check for parentheses
        elseif char == plume.lua_syntax.call_begin then
            self:write ()
            self:newtoken ("lua_call_begin", char)
        elseif char == plume.lua_syntax.call_end then
            self:write ()
            self:newtoken ("lua_call_end", char)

        -- Check for brackets
        elseif char == plume.lua_syntax.index_begin then
            self:write ()
            self:newtoken ("lua_index_begin", char)
        elseif char == plume.lua_syntax.index_end then
            self:write ()
            self:newtoken ("lua_index_end", char)

        -- Check for braces
        elseif char == plume.lua_syntax.table_begin then
            self:write ()
            self:newtoken ("lua_table_begin", char)
        elseif char == plume.lua_syntax.table_end then
            self:write ()
            self:newtoken ("lua_table_end", char)
        

        -- Check for plume block
        elseif char == plume.syntax.eval then
            local next = self.code:sub(self.pos+1, self.pos+1)

            -- Inside lua code, $ must be followed by a brace.
            if next ~= plume.syntax.block_begin then
                self:newtoken ("invalid", next, 2)
                plume.syntax_error_wrong_eval_inside_lua (self.tokenlist[#self.tokenlist], next)
            end
            self:write ()
            self:newtoken ("eval", char, 1)
            self:newtoken ("block_begin", plume.syntax.block_begin, 1)

            -- Switch to plume syntax
            table.insert(self.context, "plume")

            self.pos = self.pos + 1

        -- Check for identifier
        elseif char:match(plume.lua_syntax.identifier) then
            self:write("lua_word")
            table.insert(self.acc, char)
        elseif char:match("%s") then
            self:write ("space")
            table.insert(self.acc, char)

        else
            self:write ("lua_code")
            table.insert(self.acc, char)
        end

    -- If mode is not anymore "lua", close the lua block
    else
        self:write()

        -- Plume will add code a the end of the used script.
        -- So do somme simple checks to avoid confusing error message.
        local last = self.tokenlist[#self.tokenlist]
        if last.kind == "lua_code" then
            self:newtoken ("invalid", last, 2)
            plume.syntax_error_lua_eof (last)
        end

        self:newtoken ("block_end", plume.syntax.block_end, 1)
    end
end

--- Handles Lua string
-- @param delimiter string The delimiter that marks the end of the Lua string.
function plume.tokenizer:handle_context_lua_string(delimiter)
    local char = self.code:sub(self.pos, self.pos)
    self:write("lua_string")

    -- If char is the delimiter, exit from string context
    if char == delimiter then
        table.insert(self.acc, char)
        table.remove(self.context)

    -- If the character is an escape character, take the next character as well
    elseif char == plume.lua_syntax.escape then
        local next = self.code:sub(self.pos + 1, self.pos + 1)
        table.insert(self.acc, char)
        table.insert(self.acc, next)

        self.pos = self.pos + 1

    -- If it's a regular character, simply add it to the accumulator
    else
        table.insert(self.acc, char)
    end
end

--- Handles the beginning of a Lua block
-- Checks if the following code is an identifier or a block
function plume.tokenizer:handle_lua_block_begin ()
    local char = self.code:sub(self.pos, self.pos)

    self:write()
    self.pos = self.pos + 1
    self:newtoken ("eval", char)
    self.tokenlist[#self.tokenlist].is_lua_code = true
    local next = self.code:sub(self.pos, self.pos)

    -- If the next characters are alphanumeric, capture the next
    -- identifier as a block and not %S+.
    -- So "$a+1" is interpreted as "\eval{a}+1", not "\eval{a+1}".
    if next:match(plume.syntax.identifier_begin) then
        local name = self.code:sub(self.pos, -1):match(plume.syntax.identifier .. '+')
        self.pos = self.pos + #name - 1
        self:newtoken ("text", name)

    -- Otherwise, if the next character is the beginning of a block, switch context to parse Lua code
    elseif next == plume.syntax.block_begin then
        self:newtoken ("block_begin", plume.syntax.block_begin, 1)
        table.insert(self.context, "lua")
        self.lua_last_keyword = ""

    -- The "$" character must be followed by "{" or an identifier, otherwise raise an error.
    else
        -- Create a token for the error message
        self:newtoken ("invalid", next)
        plume.syntax_error_wrong_eval (self.tokenlist[#self.tokenlist], next)
    end
end

function plume.tokenizer:lua_checks_keywords (mode, word)
    if plume.lua_syntax.statement:match(" " .. word .. " ") and (self.lua_last_keyword ~= "for" or word ~= "do") and (self.lua_last_keyword ~= "while" or word ~= "do")then
        self.lua_last_keyword = word
        return "lua_statement"
    elseif plume.lua_syntax.keyword:match(" " .. word .. " ") then
        return "lua_code"
    elseif plume.lua_syntax.statement_alone:match(" " .. word .. " ") then
        return "lua_statement_alone"
    elseif plume.lua_syntax.function_keyword == word then
        return "lua_function"
    elseif plume.lua_syntax.end_keyword == word then
        return "lua_end"
    elseif plume.lua_syntax.return_keyword == word then
        return "lua_return"
    end

    return mode
end

--- Checks if the current position is the start of a lua comment
-- @return boolean
function plume.tokenizer:check_for_lua_comment (char)
    local char = self.code:sub(self.pos, self.pos)

    if char == plume.lua_syntax.comment then
        local next  = self.code:sub(self.pos+1, self.pos+1)

        if next == char then
            return true
        end
    end

    return false
end
end
plume_files['plume-engine.tokenize_plume'] = function ()


--- Handles plume syntax
-- @param char string The syntax character to be handled
function plume.tokenizer:handle_context_plume ()
    local char = self.code:sub(self.pos, self.pos)

    if char == plume.syntax.opt_assign then
        self:write()
        self:newtoken("opt_assign", plume.syntax.opt_assign, 1)
    
    -- Checks for comment
    elseif self:check_for_comment () then
        plume.tokenizer:handle_comment ()

    -- If char is an escape, look ahead.
    elseif char == plume.syntax.escape then
        local next  = self.code:sub(self.pos+1, self.pos+1)

        -- If the following char is a valid identifier, assume that it is a macro call  
        if next:match(plume.syntax.identifier_begin) then
            self:write()
            self.mode = "macro"
            table.insert(self.acc, char)

        -- Else, just write the following char
        else
            self:write()
            self:newtoken ("escaped_text", next)
            self.pos = self.pos + 1
        end
    
    -- Handle braces and spaces
    -- Manage depth through self.context
    elseif char == plume.syntax.block_begin then
        self:write()
        self:newtoken ("block_begin", plume.syntax.block_begin, 1)
        table.insert(self.context, "plume")
    elseif char == plume.syntax.block_end then
        self:write()
        self:newtoken ("block_end", plume.syntax.block_end, 1)
        table.remove(self.context)
    elseif char == plume.syntax.opt_block_begin then
        self:write()
        self:newtoken ("opt_block_begin", plume.syntax.opt_block_begin, 1)
    elseif char == plume.syntax.opt_block_end then
        self:write()
        self:newtoken ("opt_block_end", plume.syntax.opt_block_end, 1)
    elseif char:match("%s") then
        self:write ("space")
        table.insert(self.acc, char)
    
    -- "$" is the begin of a lua block
    elseif char == plume.syntax.eval then
        self:handle_lua_block_begin (char)

    -- If in macro mode, add the current char to the macro name or,
    -- if the char it isn't a valid identifier, end the macro.
    -- Else just write the char as raw text
    else
        if self.mode == "macro" and char:match(plume.syntax.identifier) then
            self:write ("macro")
        else
            self:write ("text")
        end
        table.insert(self.acc, char)
    end
end

--- Checks if the current position is the start of a comment
-- @return boolean
function plume.tokenizer:check_for_comment (char)
    local char = self.code:sub(self.pos, self.pos)

    -- A comment start by an escape
    if char == plume.syntax.escape then
        local next  = self.code:sub(self.pos+1, self.pos+1)
        local next2 = self.code:sub(self.pos+2, self.pos+2)

        -- Followed by two "minus"
        if next == plume.syntax.comment and next == next2 then
            return true
        end
    end

    return false
end

--- Handles comments
-- This function captures comment text and advances through the code until 
-- a newline is encountered (and captures also all spaces following the newline)
-- @param keep_all_spaces bool If false, all following spaces are removed.
-- It is the default behavior in plume code, but Lua code needs to keep these spaces.
function plume.tokenizer:handle_comment (keep_all_spaces)
    self:write("comment")
    table.insert(self.acc, char)
    local find_newline

    -- Iterate over characters until the end of the code or a newline is found
    repeat
        self.pos = self.pos + 1
        next = self.code:sub(self.pos, self.pos)

        -- Check for spaces or tabs following the newline to stop reading
        if find_newline and not next:match "[ \t]" then
            self.pos = self.pos - 1
            break
        end

        table.insert(self.acc, next)
        if next == "\n" then
            if keep_all_spaces then
                self.pos  = self.pos-1
                break
            else
                find_newline = self.pos + 1
            end
        end
    until self.pos >= #self.code

    -- Update of line number and line position if a new line has been found
    if find_newline then
        self.noline = self.noline + 1
        self.linepos = find_newline
    end
end
end
plume = require('plume-engine.init')
</script>

<script type="application/lua">
js = require("js")
global = js.global
local document = global.document

local function updateOutput()
    plume.init()
    plume.running_api.config.filter_spaces   = " "
    plume.running_api.config.filter_newlines = "</p><p>"

    local inputElement = document:getElementById("input")
    local outputElement = document:getElementById("output")

    local sucess, result = pcall(plume.render, inputElement.value)

    if sucess then
        outputElement.innerHTML = "<p>" .. result .. "</p>"
    else
        outputElement.innerHTML = "<pre>" .. result .. "</pre>"
    end
end

local inputElement = document:getElementById("input")

inputElement:addEventListener("input", updateOutput)

local function handle_tab(self, event)
    if event.key == "Tab" then
        event:preventDefault()

        local input = document:getElementById("input")
        local start = input.selectionStart
        local finish = input.selectionEnd
        
        -- Add the tab character
        input.value = input.value:sub(1, start) .. "\t" .. input.value:sub(finish + 1)

        -- Move the cursor to the correct position after the tab
        input.selectionStart = start + 1
        input.selectionEnd = start + 1
    end
end

document:getElementById("input"):addEventListener("keydown", handle_tab)

updateOutput()

</script>